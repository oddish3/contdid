next
}
tryCatch({
npiv_result <- npiv(PP1, BB1, y)
u1 <- npiv_result$u
Q1 <- npiv_result$Q
Bu1 <- sweep(BB1, 1, u1, `*`)
cat("Dimensions of Bu1:", dim(Bu1), "\n")
OL1 <- Q1 %*% (t(Bu1) %*% Bu1 / n) %*% t(Q1)
tden <- numeric(nrow(Px1))
for (x in 1:nrow(Px1)) {
s1 <- Px1[x, ] %*% OL1 %*% Px1[x, ]
tden[x] <- sqrt(s1)
}
for (b in 1:nb) {
Buw1 <- t(Bu1) %*% omega[1:nrow(Bu1), b] / sqrt(n)
tnum <- Px1 %*% Q1 %*% Buw1
ZZ[i, b] <- switch(as.character(type),
"0" = max(abs(tnum / tden)),
"-1" = max(tnum / tden),
"1" = min(tnum / tden))
}
}, error = function(e) {
warning("Error in iteration ", i, ": ", e$message)
})
}
if (all(ZZ == 0)) stop("All iterations failed or produced zero values")
z <- if (type %in% c(0, -1)) apply(ZZ, 2, max) else apply(ZZ, 2, min)
cv <- if (type %in% c(0, -1)) quantile(z, 1 - alpha) else -quantile(z, alpha)
return(cv)
}
ucb_cv(Ltil, Lhat, Px, PP, PP, CJ, CJ, y, n, 1000, 0, alpha)
ucb_cv(Ltil, Lhat, Px, PP, PP, CJ, CJ, y, n, 1000, 0)
ucb_cv <- function(Ltil, Lhat, Px, PP, BB, CJ, CK, y, nb, type, alpha = 0.05) {
# Input validation
if (length(CJ) < 2) stop("CJ must have at least 2 elements")
if (!is.numeric(Ltil) || !is.numeric(Lhat)) stop("Ltil and Lhat must be numeric")
if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) stop("alpha must be a number between 0 and 1")
cat("Ltil:", Ltil, "Lhat:", Lhat, "\n")
cat("Length of CJ:", length(CJ), "First few elements:", head(CJ), "\n")
cat("Dimensions of Px:", dim(Px), "\n")
cat("Dimensions of PP:", dim(PP), "\n")
cat("Dimensions of BB:", dim(BB), "\n")
n_Px <- nrow(Px)
n_PP <- nrow(PP)
if (n_Px != n_PP) {
warning("Mismatch in number of rows between Px and PP. Using the smaller dimension.")
n <- min(n_Px, n_PP)
Px <- Px[1:n, , drop = FALSE]
PP <- PP[1:n, , drop = FALSE]
BB <- BB[1:n, , drop = FALSE]
y <- y[1:n]
} else {
n <- n_Px
}
Lmax <- Lhat + 1
omega <- matrix(rnorm(n * nb), n, nb)
num_iterations <- min(max(Ltil, Lmax - 2, 1), length(CJ) - 1)
if (num_iterations < 1) stop("No valid iterations possible with given parameters")
ZZ <- matrix(0, num_iterations, nb)
cat("Number of iterations:", num_iterations, "\n")
cat("Dimensions of ZZ:", dim(ZZ), "\n")
cat("Dimensions of omega:", dim(omega), "\n")
for (i in 1:num_iterations) {
end_idx <- min(CJ[i + 1], ncol(Px))
Px1 <- Px[, (CJ[i] + 1):end_idx, drop = FALSE]
PP1 <- PP[, (CJ[i] + 1):end_idx, drop = FALSE]
end_idx_BB <- min(CK[i + 1], ncol(BB))
BB1 <- BB[, (CK[i] + 1):end_idx_BB, drop = FALSE]
cat("Iteration", i, "\n")
cat("Dimensions of Px1:", dim(Px1), "\n")
cat("Dimensions of PP1:", dim(PP1), "\n")
cat("Dimensions of BB1:", dim(BB1), "\n")
if (ncol(BB1) == 0) {
warning("BB1 is empty in iteration ", i, ". Skipping this iteration.")
next
}
tryCatch({
npiv_result <- npiv(PP1, BB1, y)
u1 <- npiv_result$u
Q1 <- npiv_result$Q
Bu1 <- sweep(BB1, 1, u1, `*`)
cat("Dimensions of Bu1:", dim(Bu1), "\n")
OL1 <- Q1 %*% (t(Bu1) %*% Bu1 / n) %*% t(Q1)
tden <- numeric(nrow(Px1))
for (x in 1:nrow(Px1)) {
s1 <- Px1[x, ] %*% OL1 %*% Px1[x, ]
tden[x] <- sqrt(s1)
}
for (b in 1:nb) {
Buw1 <- t(Bu1) %*% omega[1:nrow(Bu1), b] / sqrt(n)
tnum <- Px1 %*% Q1 %*% Buw1
ZZ[i, b] <- switch(as.character(type),
"0" = max(abs(tnum / tden)),
"-1" = max(tnum / tden),
"1" = min(tnum / tden))
}
}, error = function(e) {
warning("Error in iteration ", i, ": ", e$message)
})
}
if (all(ZZ == 0)) stop("All iterations failed or produced zero values")
z <- if (type %in% c(0, -1)) apply(ZZ, 2, max) else apply(ZZ, 2, min)
cv <- if (type %in% c(0, -1)) quantile(z, 1 - alpha) else -quantile(z, alpha)
return(cv)
}
ucb_cv(Ltil, Lhat, Px, PP, PP, CJ, CJ, y, n, 1000, 0)
ucb_cv(Ltil, Lhat, Px, PP, PP, CJ, CJ, y, n, 1000)
ucb_cv <- function(Ltil, Lhat, Px, PP, BB, CJ, CK, y, nb, type, alpha = 0.05) {
# Input validation
if (length(CJ) < 2) stop("CJ must have at least 2 elements")
if (!is.numeric(Ltil) || !is.numeric(Lhat)) stop("Ltil and Lhat must be numeric")
if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) stop("alpha must be a number between 0 and 1")
cat("Ltil:", Ltil, "Lhat:", Lhat, "\n")
cat("Length of CJ:", length(CJ), "First few elements:", head(CJ), "\n")
cat("Dimensions of Px:", dim(Px), "\n")
cat("Dimensions of PP:", dim(PP), "\n")
cat("Dimensions of BB:", dim(BB), "\n")
cat("CJ:", CJ "\n")
ucb_cv <- function(Ltil, Lhat, Px, PP, BB, CJ, CK, y, nb, type, alpha = 0.05) {
# Input validation
if (length(CJ) < 2) stop("CJ must have at least 2 elements")
if (!is.numeric(Ltil) || !is.numeric(Lhat)) stop("Ltil and Lhat must be numeric")
if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) stop("alpha must be a number between 0 and 1")
cat("Ltil:", Ltil, "Lhat:", Lhat, "\n")
cat("Dimensions of Px:", dim(Px), "\n")
cat("Dimensions of PP:", dim(PP), "\n")
cat("Dimensions of BB:", dim(BB), "\n")
cat("CJ:", CJ "\n")
ucb_cv <- function(Ltil, Lhat, Px, PP, BB, CJ, CK, y, nb, type, alpha = 0.05) {
# Input validation
if (length(CJ) < 2) stop("CJ must have at least 2 elements")
if (!is.numeric(Ltil) || !is.numeric(Lhat)) stop("Ltil and Lhat must be numeric")
if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) stop("alpha must be a number between 0 and 1")
cat("Ltil:", Ltil, "Lhat:", Lhat, "\n")
cat("Dimensions of Px:", dim(Px), "\n")
cat("Dimensions of PP:", dim(PP), "\n")
cat("Dimensions of BB:", dim(BB), "\n")
cat("CJ:", CJ, "\n")
cat("y:", head(y), "\n")
cat("type:", type, "\n")
cat("alpha:", a, "\n")
n_Px <- nrow(Px)
n_PP <- nrow(PP)
if (n_Px != n_PP) {
warning("Mismatch in number of rows between Px and PP. Using the smaller dimension.")
n <- min(n_Px, n_PP)
Px <- Px[1:n, , drop = FALSE]
PP <- PP[1:n, , drop = FALSE]
BB <- BB[1:n, , drop = FALSE]
y <- y[1:n]
} else {
n <- n_Px
}
Lmax <- Lhat + 1
omega <- matrix(rnorm(n * nb), n, nb)
num_iterations <- min(max(Ltil, Lmax - 2, 1), length(CJ) - 1)
if (num_iterations < 1) stop("No valid iterations possible with given parameters")
ZZ <- matrix(0, num_iterations, nb)
cat("Number of iterations:", num_iterations, "\n")
cat("Dimensions of ZZ:", dim(ZZ), "\n")
cat("Dimensions of omega:", dim(omega), "\n")
for (i in 1:num_iterations) {
end_idx <- min(CJ[i + 1], ncol(Px))
Px1 <- Px[, (CJ[i] + 1):end_idx, drop = FALSE]
PP1 <- PP[, (CJ[i] + 1):end_idx, drop = FALSE]
end_idx_BB <- min(CK[i + 1], ncol(BB))
BB1 <- BB[, (CK[i] + 1):end_idx_BB, drop = FALSE]
cat("Iteration", i, "\n")
cat("Dimensions of Px1:", dim(Px1), "\n")
cat("Dimensions of PP1:", dim(PP1), "\n")
cat("Dimensions of BB1:", dim(BB1), "\n")
if (ncol(BB1) == 0) {
warning("BB1 is empty in iteration ", i, ". Skipping this iteration.")
next
}
tryCatch({
npiv_result <- npiv(PP1, BB1, y)
u1 <- npiv_result$u
Q1 <- npiv_result$Q
Bu1 <- sweep(BB1, 1, u1, `*`)
cat("Dimensions of Bu1:", dim(Bu1), "\n")
OL1 <- Q1 %*% (t(Bu1) %*% Bu1 / n) %*% t(Q1)
tden <- numeric(nrow(Px1))
for (x in 1:nrow(Px1)) {
s1 <- Px1[x, ] %*% OL1 %*% Px1[x, ]
tden[x] <- sqrt(s1)
}
for (b in 1:nb) {
Buw1 <- t(Bu1) %*% omega[1:nrow(Bu1), b] / sqrt(n)
tnum <- Px1 %*% Q1 %*% Buw1
ZZ[i, b] <- switch(as.character(type),
"0" = max(abs(tnum / tden)),
"-1" = max(tnum / tden),
"1" = min(tnum / tden))
}
}, error = function(e) {
warning("Error in iteration ", i, ": ", e$message)
})
}
if (all(ZZ == 0)) stop("All iterations failed or produced zero values")
z <- if (type %in% c(0, -1)) apply(ZZ, 2, max) else apply(ZZ, 2, min)
cv <- if (type %in% c(0, -1)) quantile(z, 1 - alpha) else -quantile(z, alpha)
return(cv)
}
ucb_cv(Ltil, Lhat, Px, PP, PP, CJ, CJ, y, n, 1000, 0, alpha)
ucb_cv(Ltil, Lhat, Px, PP, PP, CJ, CJ, y, nb = 1000, type = 0, alpha = alpha)
ucb_cv <- function(Ltil, Lhat, Px, PP, BB, CJ, CK, y, nb, type, alpha = 0.05) {
# Input validation
if (length(CJ) < 2) stop("CJ must have at least 2 elements")
if (!is.numeric(Ltil) || !is.numeric(Lhat)) stop("Ltil and Lhat must be numeric")
if (!is.numeric(alpha) || alpha <= 0 || alpha >= 1) stop("alpha must be a number between 0 and 1")
cat("Ltil:", Ltil, "Lhat:", Lhat, "\n")
cat("Dimensions of Px:", dim(Px), "\n")
cat("Dimensions of PP:", dim(PP), "\n")
cat("Dimensions of BB:", dim(BB), "\n")
cat("CJ:", CJ, "\n")
cat("y:", head(y), "\n")
cat("type:", type, "\n")
cat("alpha:", alpha, "\n")
n_Px <- nrow(Px)
n_PP <- nrow(PP)
if (n_Px != n_PP) {
warning("Mismatch in number of rows between Px and PP. Using the smaller dimension.")
n <- min(n_Px, n_PP)
Px <- Px[1:n, , drop = FALSE]
PP <- PP[1:n, , drop = FALSE]
BB <- BB[1:n, , drop = FALSE]
y <- y[1:n]
} else {
n <- n_Px
}
Lmax <- Lhat + 1
omega <- matrix(rnorm(n * nb), n, nb)
num_iterations <- min(max(Ltil, Lmax - 2, 1), length(CJ) - 1)
if (num_iterations < 1) stop("No valid iterations possible with given parameters")
ZZ <- matrix(0, num_iterations, nb)
cat("Number of iterations:", num_iterations, "\n")
cat("Dimensions of ZZ:", dim(ZZ), "\n")
cat("Dimensions of omega:", dim(omega), "\n")
for (i in 1:num_iterations) {
end_idx <- min(CJ[i + 1], ncol(Px))
Px1 <- Px[, (CJ[i] + 1):end_idx, drop = FALSE]
PP1 <- PP[, (CJ[i] + 1):end_idx, drop = FALSE]
end_idx_BB <- min(CK[i + 1], ncol(BB))
BB1 <- BB[, (CK[i] + 1):end_idx_BB, drop = FALSE]
cat("Iteration", i, "\n")
cat("Dimensions of Px1:", dim(Px1), "\n")
cat("Dimensions of PP1:", dim(PP1), "\n")
cat("Dimensions of BB1:", dim(BB1), "\n")
if (ncol(BB1) == 0) {
warning("BB1 is empty in iteration ", i, ". Skipping this iteration.")
next
}
tryCatch({
npiv_result <- npiv(PP1, BB1, y)
u1 <- npiv_result$u
Q1 <- npiv_result$Q
Bu1 <- sweep(BB1, 1, u1, `*`)
cat("Dimensions of Bu1:", dim(Bu1), "\n")
OL1 <- Q1 %*% (t(Bu1) %*% Bu1 / n) %*% t(Q1)
tden <- numeric(nrow(Px1))
for (x in 1:nrow(Px1)) {
s1 <- Px1[x, ] %*% OL1 %*% Px1[x, ]
tden[x] <- sqrt(s1)
}
for (b in 1:nb) {
Buw1 <- t(Bu1) %*% omega[1:nrow(Bu1), b] / sqrt(n)
tnum <- Px1 %*% Q1 %*% Buw1
ZZ[i, b] <- switch(as.character(type),
"0" = max(abs(tnum / tden)),
"-1" = max(tnum / tden),
"1" = min(tnum / tden))
}
}, error = function(e) {
warning("Error in iteration ", i, ": ", e$message)
})
}
if (all(ZZ == 0)) stop("All iterations failed or produced zero values")
z <- if (type %in% c(0, -1)) apply(ZZ, 2, max) else apply(ZZ, 2, min)
cv <- if (type %in% c(0, -1)) quantile(z, 1 - alpha) else -quantile(z, alpha)
return(cv)
}
ucb_cv(Ltil, Lhat, Px, PP, PP, CJ, CJ, y, nb = 1000, type = 0, alpha = alpha)
ucb_cv(Ltil, Lhat, Px, PP, PP, CJ, CJ, y, nb = 1000, type = 0, alpha = alpha)
res <- ucb_cv(Ltil, Lhat, Px, PP, PP, CJ, CJ, y, nb = 1000, type = 0, alpha = alpha)
res
hzast <- ucb_cv(Ltil, Lhat, Px, PP, PP, CJ, CJ, y, n, 1000, 0, alpha)
res1 <- ucb_cv(Ltil, Lhat, Dx, PP, PP, CJ, CJ, y, nb = 1000, type = 0, alpha = alpha)
rm(list=ls())
library(contdid)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
set.seed(123)  # for reproducibility
results <- gdata(100, dgp = 4)
data <- results$data
info <- results$info
data <- data %>%
filter((dose > 0.25 & dose < 0.75) | dose == 0) %>%
mutate(dose = (dose - min(dose)) / (max(dose) - min(dose)))
# debugonce(npiv_regression)
npiv_result <- npiv_regression(data, "dose", "dy")
rm(list=ls())
library(contdid)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
set.seed(123)  # for reproducibility
results <- gdata(100, dgp = 4)
data <- results$data
info <- results$info
data <- data %>%
filter((dose > 0.25 & dose < 0.75) | dose == 0) %>%
mutate(dose = (dose - min(dose)) / (max(dose) - min(dose)))
# debugonce(npiv_regression)
npiv_result <- npiv_regression(data, "dose", "dy")
rm(list=ls())
library(contdid)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
set.seed(123)  # for reproducibility
results <- gdata(100, dgp = 4)
data <- results$data
info <- results$info
# data <- data %>%
#   filter((dose > 0.25 & dose < 0.75) | dose == 0) %>%
#   mutate(dose = (dose - min(dose)) / (max(dose) - min(dose)))
# debugonce(npiv_regression)
npiv_result <- npiv_regression(data, "dose", "dy")
View(npiv_result)
npiv_result[["hzast"]]
devtools::load_all()
rm(list=ls())
library(contdid)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
set.seed(123)  # for reproducibility
results <- gdata(100, dgp = 4)
data <- results$data
info <- results$info
data <- data %>%
filter((dose > 0.25 & dose < 0.75) | dose == 0) %>%
mutate(dose = (dose - min(dose)) / (max(dose) - min(dose)))
# debugonce(npiv_regression)
npiv_result <- npiv_regression(data, "dose", "dy")
devtools::load_all()
rm(list=ls())
library(contdid)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
set.seed(123)  # for reproducibility
results <- gdata(100, dgp = 4)
data <- results$data
info <- results$info
data <- data %>%
filter((dose > 0.25 & dose < 0.75) | dose == 0) %>%
mutate(dose = (dose - min(dose)) / (max(dose) - min(dose)))
# debugonce(npiv_regression)
npiv_result <- npiv_regression(data, "dose", "dy")
rm(list=ls())
library(contdid)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
set.seed(123)  # for reproducibility
results <- gdata(100, dgp = 4)
data <- results$data
info <- results$info
data <- data %>%
filter((dose > 0.25 & dose < 0.75) | dose == 0) %>%
mutate(dose = (dose - min(dose)) / (max(dose) - min(dose)))
# debugonce(npiv_regression)
npiv_result <- npiv_regression(data, "dose", "dy")
devtools::load_all()
rm(list=ls())
library(contdid)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
set.seed(123)  # for reproducibility
results <- gdata(100, dgp = 4)
data <- results$data
info <- results$info
data <- data %>%
filter((dose > 0.25 & dose < 0.75) | dose == 0) %>%
mutate(dose = (dose - min(dose)) / (max(dose) - min(dose)))
# debugonce(npiv_regression)
npiv_result <- npiv_regression(data, "dose", "dy")
devtools::load_all()
rm(list=ls())
library(contdid)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
set.seed(123)  # for reproducibility
results <- gdata(100, dgp = 4)
data <- results$data
info <- results$info
data <- data %>%
filter((dose > 0.25 & dose < 0.75) | dose == 0) %>%
mutate(dose = (dose - min(dose)) / (max(dose) - min(dose)))
# debugonce(npiv_regression)
npiv_result <- npiv_regression(data, "dose", "dy")
npiv_result[["hzast"]]
npiv_result[["dzast"]]
source("~/Documents/uni/master-dissertation/contdid/R/ucb_cv.R")
devtools::load_all()
rm(list=ls())
library(contdid)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
set.seed(123)  # for reproducibility
results <- gdata(100, dgp = 4)
data <- results$data
info <- results$info
# data <- data %>%
#   filter((dose > 0.25 & dose < 0.75) | dose == 0) %>%
#   mutate(dose = (dose - min(dose)) / (max(dose) - min(dose)))
# debugonce(npiv_regression)
npiv_result <- npiv_regression(data, "dose", "dy")
npiv_result[["hzast"]]
npiv_result[["dzast"]]
rm(list=ls())
library(contdid)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
set.seed(123)  # for reproducibility
results <- gdata(100, dgp = 4)
data <- results$data
info <- results$info
data <- data %>%
filter((dose > 0.25 & dose < 0.75) | dose == 0)
# %>%
#   mutate(dose = (dose - min(dose)) / (max(dose) - min(dose)))
# debugonce(npiv_regression)
npiv_result <- npiv_regression(data, "dose", "dy")
rm(list=ls())
devtools::load_all()
library(contdid)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
set.seed(123)  # for reproducibility
results <- gdata(100, dgp = 4)
data <- results$data
info <- results$info
data <- data %>%
filter((dose > 0.25 & dose < 0.75) | dose == 0)
# debugonce(npiv_regression)
npiv_result <- npiv_regression(data, "dose", "dy")
npiv_result[["hzast"]]
npiv_result[["dzast"]]
rm(list=ls())
devtools::load_all()
library(contdid)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
set.seed(123)  # for reproducibility
results <- gdata(100, dgp = 4)
data <- results$data
info <- results$info
data <- data %>%
filter((dose > 0.25 & dose < 0.75) | dose == 0) %>%
mutate(dose = (dose - min(dose)) / (max(dose) - min(dose)))
# debugonce(npiv_regression)
npiv_result <- npiv_regression(data, "dose", "dy")
npiv_result[["hzast"]]
npiv_result[["dzast"]]
rm(list=ls())
devtools::load_all()
library(contdid)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
set.seed(123)  # for reproducibility
results <- gdata(100, dgp = 4)
data <- results$data
info <- results$info
data <- data %>%
filter((dose > 0.25 & dose < 0.75) | dose == 0) %>%
mutate(dose = (dose - min(dose)) / (max(dose) - min(dose)))
rm(list=ls())
devtools::load_all()
library(contdid)
library(tidyverse)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
set.seed(123)  # for reproducibility
results <- gdata(100, dgp = 4)
data <- results$data
info <- results$info
data <- data %>%
filter((dose > 0.25 & dose < 0.75) | dose == 0) %>%
mutate(dose = (dose - min(dose)) / (max(dose) - min(dose)))
# debugonce(npiv_regression)
npiv_result <- npiv_regression(data, "dose", "dy")
npiv_result[["hzast"]]
npiv_result[["dzast"]]
View(results)
View(npiv_result)
View(npiv_result)
rm(list=ls())
devtools::load_all()
library(contdid)
library(tidyverse)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
set.seed(123)  # for reproducibility
results <- gdata(100, dgp = 4)
data <- results$data
info <- results$info
# data <- data %>%
#   filter((dose > 0.25 & dose < 0.75) | dose == 0) %>%
#   mutate(dose = (dose - min(dose)) / (max(dose) - min(dose)))
# debugonce(npiv_regression)
npiv_result <- npiv_regression(data, "dose", "dy")
rm(list=ls())
devtools::load_all()
library(contdid)
library(tidyverse)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
set.seed(123)  # for reproducibility
results <- gdata(100, dgp = 4)
data <- results$data
info <- results$info
# data <- data %>%
#   filter((dose > 0.25 & dose < 0.75) | dose == 0) %>%
#   mutate(dose = (dose - min(dose)) / (max(dose) - min(dose)))
# debugonce(npiv_regression)
npiv_result <- npiv_regression(data, "dose", "dy")
npiv_result[["hzast"]]
npiv_result[["dzast"]]
View(npiv_result)
