outcome_col = "dy",
)
# write_debug_info("npiv_regression completed successfully")
result
}, error = function(e) {
# write_debug_info(paste("Error in npiv_regression:", e$message))
return(NULL)
})
if (is.null(npiv_result)) {
# write_debug_info("Skipping rest of iteration due to npiv_regression failure")
return(NULL)
}
true_att <- info[["pop_att"]]
npiv_att_estimate <- npiv_result[["binarised"]][["estimate"]][["binary"]]
npiv_att_se <- npiv_result[["binarised"]][["std_error"]][["binary"]]
npiv_att_l <- npiv_result[["binarised"]][["lower_ci"]]
npiv_att_h <- npiv_result[["binarised"]][["upper_ci"]]
npiv_metrics <- calculate_point_metrics(npiv_att_estimate, true_att, npiv_att_se, npiv_att_l, npiv_att_h)
# compute true func
x_grid <- seq(0, 1, length.out = length(info$func_values))
closest_indices <- sapply(npiv_result$Xx, function(x) which.min(abs(x_grid - x)))
h0 <- info$func_values[closest_indices]
d0 <- info$func_deriv_values[closest_indices]
info$func_deriv_value
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = dgp)
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = dgp)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = dgp)
x_grid <- seq(0, 1, length.out = 1000)
func_values <- dgp_params$func(x_grid)
func_deriv_values <- if (length(dgp_params$func_deriv) == 1) {
rep(dgp_params$func_deriv, length(x_grid))
} else if (is.function(dgp_params$func_deriv)) {
dgp_params$func_deriv(x_grid)
} else {
stop("dgp_params$func_deriv must be either a scalar or a function")
}
func_deriv_values <- if (length(dgp_params$func_deriv) == 1) {
rep(dgp_params$func_deriv, length(x_grid))
} else if (is.function(dgp_params$func_deriv)) {
dgp_params$func_deriv(x_grid)
} else {
stop("dgp_params$func_deriv must be either a scalar or a function")
}
length(dgp_params$func_deriv) == 1
rep(dgp_params$func_deriv, length(x_grid))
dgp_params$func_deri
dgp_params$func_deriv
length(x_grid)
View(dgp_params)
body(dgp_params[["func_deriv"]])
func_deriv_values <- if (length(dgp_params$func_deriv) == 1) {
rep(body(dgp_params[["func_deriv"]]), length(x_grid))
} else if (is.function(dgp_params$func_deriv)) {
dgp_params$func_deriv(x_grid)
} else {
stop("dgp_params$func_deriv must be either a scalar or a function")
}
func_deriv_values <- if (length(dgp_params$func_deriv) == 1) {
rep(body(dgp_params[["func_deriv"]]), length(x_grid))
} else if (is.function(dgp_params$func_deriv)) {
dgp_params$func_deriv(x_grid)
} else {
stop("dgp_params$func_deriv must be either a scalar or a function")
}
dgp_params$func_deriv) == 1
(length(dgp_params$func_deriv) == 1)
rep(body(dgp_params[["func_deriv"]]), length(x_grid))
is.function(dgp_params$func_deriv)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = dgp)
View(dat)
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 1)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 1)
rep(body(dgp_params[["func_deriv"]]), length(x_grid))
View(dgp_params)
body(dgp_params[["func_deriv"]])
View(dgp_params)
# Define the dgp_function
dgp_function <- function(dgp) {
x_grid <- seq(0, 1, length.out = 1000)
get_values <- function(f) {
if (is.numeric(f) && length(f) == 1) {
rep(f, length(x_grid))
} else if (is.function(f)) {
f(x_grid)
} else {
stop("Input must be either a scalar or a function")
}
}
if (dgp == 1) {
dist <- function(n) runif(n, 0, 1)
func <- function(x) x^2
func_deriv <- function(x) 2*x
E_func <- 1/3
E_deriv <- 1
} else if (dgp == 2) {
dist <- function(n) rtriangle(n, a=0, b=1, c=1)
func <- function(x) 3*x - 1
func_deriv <- 3  # Now a scalar
E_func <- 1/2
E_deriv <- 3
} else if (dgp == 3) {
dist <- function(n) runif(n, 0, 1)
func <- function(x) x^3
func_deriv <- function(x) 3*x^2
E_func <- 1/4
E_deriv <- 1
} else if (dgp == 4) {
dist <- function(n) rbeta(n, 2, 3)
func <- function(x) (x^2 + x) / 2
func_deriv <- function(x) x + 1/2
E_func <- 5/12
E_deriv <- 7/5
} else {
stop("Invalid dgp value")
}
return(list(
dist = dist,
func = get_values(func),
func_deriv = get_values(func_deriv),
E_func = E_func,
E_deriv = E_deriv,
x_grid = x_grid
))
}
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 1)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 1)
# Get the appropriate dist, func, and func_deriv based on the dgp value
dgp_params <- dgp_function(dgp)
# Generate treatment assignment
treatment <- rbinom(n, 1, prop_treated)
# Generate dose for treated units using the dist function
dose <- rep(0, n)
dose[treatment == 1] <- dgp_params$dist(sum(treatment))
# Generate indexes
index_base <- rnorm(n, mean = 100, sd = index_sd)  # Reduced SD for base index
index_unobs_het <- rnorm(n, mean = 0, sd = unobs_het_sd)  # Reduced SD for unobserved heterogeneity
# Generate outcomes at time 1 (pre-treatment)
y1 <- index_base + index_unobs_het + rnorm(n, mean = 0, sd = noise_sd)
# Calculate treatment effect for treated units using the func function
treatment_effect <- ifelse(treatment == 1, dgp_params$func(dose), 0)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 2)
data <- dat[["data"]]
info <- dat[["info"]]
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 1)
data <- dat[["data"]]
info <- dat[["info"]]
# Define the dgp_function as before
dgp_function <- function(dgp) {
if (dgp == 1) {
dist <- function(n) runif(n, 0, 1)
func <- function(x) x^2
func_deriv <- function(x) 2*x
E_func <- 1/3
E_deriv <- 1
}
if (dgp == 2) {
dist <- function(n) rtriangle(n, a=0, b=1, c=1)
func <- function(x) 3*x - 1
func_deriv <- function(x) rep(3, length(x))
E_func <- 1/2
E_deriv <- 3
}
if (dgp == 3) {
dist <- function(n) runif(n, 0, 1)
func <- function(x) x^3
func_deriv <- function(x) 3*x^2
E_func <- 1/4
E_deriv <- 1
}
if (dgp == 4) {
dist <- function(n) rbeta(n, 2, 3)
func <- function(x) (x^2 + x) / 2
func_deriv <- function(x) x + 1/2
E_func <- 5/12
E_deriv <- 7/5
}
return(list(
dist = dist,
func = func,
func_deriv = func_deriv,
E_func = E_func,
E_deriv = E_deriv
))
}
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 1)
data <- dat[["data"]]
info <- dat[["info"]]
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 2)
data <- dat[["data"]]
info <- dat[["info"]]
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 3)
data <- dat[["data"]]
info <- dat[["info"]]
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 4)
data <- dat[["data"]]
info <- dat[["info"]]
# # Run estimators and calculate metrics
# NPIV
# debugonce(npiv_regression)
npiv_result <- tryCatch({
result <- npiv_regression(
data = data,
treatment_col = "dose",
outcome_col = "dy",
)
# write_debug_info("npiv_regression completed successfully")
result
}, error = function(e) {
# write_debug_info(paste("Error in npiv_regression:", e$message))
return(NULL)
})
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 2)
data <- dat[["data"]]
info <- dat[["info"]]
# # Run estimators and calculate metrics
# NPIV
# debugonce(npiv_regression)
npiv_result <- tryCatch({
result <- npiv_regression(
data = data,
treatment_col = "dose",
outcome_col = "dy",
)
# write_debug_info("npiv_regression completed successfully")
result
}, error = function(e) {
# write_debug_info(paste("Error in npiv_regression:", e$message))
return(NULL)
})
if (is.null(npiv_result)) {
# write_debug_info("Skipping rest of iteration due to npiv_regression failure")
return(NULL)
}
true_att <- info[["pop_att"]]
npiv_att_estimate <- npiv_result[["binarised"]][["estimate"]][["binary"]]
npiv_att_se <- npiv_result[["binarised"]][["std_error"]][["binary"]]
npiv_att_l <- npiv_result[["binarised"]][["lower_ci"]]
npiv_att_h <- npiv_result[["binarised"]][["upper_ci"]]
npiv_metrics <- calculate_point_metrics(npiv_att_estimate, true_att, npiv_att_se, npiv_att_l, npiv_att_h)
# compute true func
x_grid <- seq(0, 1, length.out = length(info$func_values))
closest_indices <- sapply(npiv_result$Xx, function(x) which.min(abs(x_grid - x)))
h0 <- info$func_values[closest_indices]
d0 <- info$func_deriv_values[closest_indices]
true_functions <- data.frame(h0 = h0, d0 = d0)
# write.csv(true_functions, "/home/oddish3/Documents/uni/master-dissertation/code-cont/r_true_functions.csv", row.names = FALSE)
# Compute UCB coverage
A <- log(log(npiv_result$TJ[npiv_result$Ltil + 1]))
# Compute coverage for ATT
att_coverage_result <- ucb_cvge(
h0 = h0,
hhat = npiv_result$hhat,
sigh = npiv_result$sigh,
zast = npiv_result$hzast[["95%"]],
theta = npiv_result$thet,
A = A
)
#NPIV ACR
true_acr <- info[["pop_acr"]]
npiv_acr_estimate <- npiv_result[["ACR_estimate"]]
npiv_acr_se <- npiv_result[["se_ACR"]]
npiv_acr_l <- npiv_result[["ci_lower_ACR"]]
npiv_acr_h <- npiv_result[["ci_upper_ACR"]]
npiv_metrics_acr <- calculate_point_metrics(npiv_acr_estimate, true_acr, npiv_acr_se, npiv_acr_l, npiv_acr_h)
# Compute coverage for ACR
acr_coverage_result <- ucb_cvge(
h0 = d0,
hhat = npiv_result$dhat,
sigh = npiv_result$sigd,
zast = npiv_result$dzast[["95%"]],
theta = npiv_result$thet,
A = A
)
npiv_result$dhat
npiv_result$sigd
npiv_result$dzast[["95%"]]
npiv_result$thet
rm(list=ls())
library(tictoc)
library(parallel)
library(doParallel)
library(foreach)
library(doRNG)
library(tidyverse)
library(fixest)
library(splines2)
library(triangle)
# remove.packages("contdid")
# devtools::build()
# devtools::install()
# devtools::load_all("~/Documents/uni/master-dissertation/contdid")
library(contdid)
# Source necessary functions
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
source("~/Documents/uni/master-dissertation/contdid/simulation/run_simulation.R")
# Set seed
seed1 <- 1234
set.seed(seed1)
n <- c(100, 500, 1000)
nrep <- 1
# Create cluster
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
# Export necessary functions to the cluster
clusterExport(cl, c("dgp_function", "gdata", "run_twfe", "run_feols_bspline", "calculate_point_metrics", "ucb_cvge",
"write_debug_info", "log_dimensions"))
# Run simulations for all DGPs
results_list <- list()
tic()
for (dgp in 2:2) {
# cat("Processing DGP:", dgp, "\n")
dgp_results <- list()
for (sample_size in n) {
# cat("  Sample size:", sample_size, "\n")
tryCatch({
dgp_results[[as.character(sample_size)]] <- run_simulation(n = sample_size, dgp = dgp, nrep = nrep)
# cat("    Completed successfully\n")
}, error = function(e) {
cat("    Error occurred:", conditionMessage(e), "\n")
})
}
results_list[[dgp]] <- do.call(rbind, dgp_results)
# cat("DGP", dgp, "completed\n\n")
}
# Stop cluster
stopCluster(cl)
toc()
View(results_list)
devtools::test()
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::test()
debugonce(npiv_regression)
devtools::load_all()
devtools::test()
library(testthat)
library(readr)
library(dplyr)
library(purrr)
library(contdid)
set.seed(1234567)
# Helper function to load CSV files
load_csv_files <- function(directory) {
tryCatch({
csv_files <- list.files(directory, pattern = "\\.csv$", full.names = TRUE)
if (length(csv_files) == 0) {
stop("No CSV files found in the specified directory")
}
message(paste("Found", length(csv_files), "CSV files"))
data_list <- map(csv_files, ~{
message(paste("Processing file:", .x))
var_name <- tools::file_path_sans_ext(basename(.x))
var_name <- sub("^123_", "", var_name)  # Remove "123_" prefix
data <- read_csv(.x, col_types = cols(), col_names = FALSE)
if (ncol(data) == 1) {
setNames(list(as.numeric(data[[1]])), var_name)
} else {
setNames(list(data), var_name)
}
}) %>% flatten()
message("CSV files loaded successfully")
return(data_list)
}, error = function(e) {
message(paste("Error in load_csv_files:", e$message))
return(NULL)
})
}
# Test function
test_matlab_equality <- function(r_result, matlab_data, tolerance = 1e-2) {
tryCatch({
common_vars <- intersect(names(r_result), names(matlab_data))
message(paste("Testing", length(common_vars), "common variables"))
for (var in common_vars) {
message(paste("Testing variable:", var))
r_value <- r_result[[var]]
matlab_value <- matlab_data[[var]]
# Convert to vector if it's a single-column data frame
restructure_variable <- function(var) {
if (is.data.frame(var) && ncol(var) == 1) {
# If the variable is a data frame with 1 column, extract the vector
var <- var[[1]]
}
if (is.matrix(var) && ncol(var) == 1) {
# If the variable is a matrix with 1 column, convert to a vector
var <- as.numeric(var)
}
if (is.array(var) && length(dim(var)) == 2 && dim(var)[2] == 1) {
# If the variable is a 2D array with 1 column, convert to a vector
var <- as.numeric(var)
}
return(var)
}
# Restructure r_value and matlab_value
r_value <- restructure_variable(r_value)
matlab_value <- restructure_variable(matlab_value)
# Check if the lengths are the same
expect_equal(length(r_value), length(matlab_value),
info = paste("Length mismatch for variable:", var))
# Check if the values are approximately equal
expect_equal(r_value, matlab_value, tolerance = tolerance,
info = paste("Value mismatch for variable:", var))
}
message("All variables tested successfully")
}, error = function(e) {
message(paste("Error in test_matlab_equality:", e$message))
})
}
tryCatch({
skip_if_not(dir.exists(test_path("data", "matlab_results")),
"MATLAB data directory not found")
skip_if_not(file.exists(test_path("data", "medicare1.csv")),
"Medicare data file not found")
message("Loading MATLAB CSV files")
matlab_data <- load_csv_files(test_path("data", "matlab_results"))
if (is.null(matlab_data)) {
skip("Failed to load MATLAB data")
}
message("Loading R data")
data <- read.csv(test_path("data", "medicare1.csv"))
message(paste("R data dimensions:", nrow(data), "x", ncol(data)))
message("Running npiv_regression")
r_result <- npiv_regression(data, "medicare_share_1983", "d_capital_labor_ratio")
message("Comparing results")
test_matlab_equality(r_result, matlab_data)
message("Test completed successfully")
}, error = function(e) {
message(paste("Error in main test:", e$message))
stop(e)
})
skip_if_not(dir.exists(test_path("data", "matlab_results")),
"MATLAB data directory not found")
skip_if_not(file.exists(test_path("data", "medicare1.csv")),
"Medicare data file not found")
message("Loading MATLAB CSV files")
matlab_data <- load_csv_files(test_path("data", "matlab_results"))
if (is.null(matlab_data)) {
skip("Failed to load MATLAB data")
}
message("Loading R data")
data <- read.csv(test_path("data", "medicare1.csv"))
message(paste("R data dimensions:", nrow(data), "x", ncol(data)))
message("Running npiv_regression")
r_result <- npiv_regression(data, "medicare_share_1983", "d_capital_labor_ratio")
debugonce(npiv_regression)
r_result <- npiv_regression(data, "medicare_share_1983", "d_capital_labor_ratio")
devtools::load_all()
devtools::test()
results_list <- readRDS("~/Documents/uni/master-dissertation/contdid/simulation/results_list.rds")
# saveRDS(results_list, file = "results_list.rds")
# Combine all results into a single data frame
all_results <- do.call(rbind, results_list)
# Calculate mean results
mean_results <- all_results %>%
group_by(n, dgp) %>%
summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)), .groups = "drop")
library(tictoc)
library(parallel)
library(doParallel)
library(foreach)
library(doRNG)
library(tidyverse)
library(fixest)
library(splines2)
library(triangle)
# saveRDS(results_list, file = "results_list.rds")
# Combine all results into a single data frame
all_results <- do.call(rbind, results_list)
# Calculate mean results
mean_results <- all_results %>%
group_by(n, dgp) %>%
summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)), .groups = "drop")
View(mean_results)
