h0 = d0,
hhat = npiv_result$dhat,
sigh = npiv_result$sigd,
zast = npiv_result$dzast[["95%"]],
theta = npiv_result$thet,
A = A
)
npiv_result$dhat
npiv_result$sigd
npiv_result$dzast[["95%"]]
npiv_result$thet
rm(list=ls())
library(tictoc)
library(parallel)
library(doParallel)
library(foreach)
library(doRNG)
library(tidyverse)
library(fixest)
library(splines2)
library(triangle)
# remove.packages("contdid")
# devtools::build()
# devtools::install()
# devtools::load_all("~/Documents/uni/master-dissertation/contdid")
library(contdid)
# Source necessary functions
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
source("~/Documents/uni/master-dissertation/contdid/simulation/run_simulation.R")
# Set seed
seed1 <- 1234
set.seed(seed1)
n <- c(100, 500, 1000)
nrep <- 1
# Create cluster
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
# Export necessary functions to the cluster
clusterExport(cl, c("dgp_function", "gdata", "run_twfe", "run_feols_bspline", "calculate_point_metrics", "ucb_cvge",
"write_debug_info", "log_dimensions"))
# Run simulations for all DGPs
results_list <- list()
tic()
for (dgp in 2:2) {
# cat("Processing DGP:", dgp, "\n")
dgp_results <- list()
for (sample_size in n) {
# cat("  Sample size:", sample_size, "\n")
tryCatch({
dgp_results[[as.character(sample_size)]] <- run_simulation(n = sample_size, dgp = dgp, nrep = nrep)
# cat("    Completed successfully\n")
}, error = function(e) {
cat("    Error occurred:", conditionMessage(e), "\n")
})
}
results_list[[dgp]] <- do.call(rbind, dgp_results)
# cat("DGP", dgp, "completed\n\n")
}
# Stop cluster
stopCluster(cl)
toc()
View(results_list)
devtools::test()
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::test()
debugonce(npiv_regression)
devtools::load_all()
devtools::test()
library(testthat)
library(readr)
library(dplyr)
library(purrr)
library(contdid)
set.seed(1234567)
# Helper function to load CSV files
load_csv_files <- function(directory) {
tryCatch({
csv_files <- list.files(directory, pattern = "\\.csv$", full.names = TRUE)
if (length(csv_files) == 0) {
stop("No CSV files found in the specified directory")
}
message(paste("Found", length(csv_files), "CSV files"))
data_list <- map(csv_files, ~{
message(paste("Processing file:", .x))
var_name <- tools::file_path_sans_ext(basename(.x))
var_name <- sub("^123_", "", var_name)  # Remove "123_" prefix
data <- read_csv(.x, col_types = cols(), col_names = FALSE)
if (ncol(data) == 1) {
setNames(list(as.numeric(data[[1]])), var_name)
} else {
setNames(list(data), var_name)
}
}) %>% flatten()
message("CSV files loaded successfully")
return(data_list)
}, error = function(e) {
message(paste("Error in load_csv_files:", e$message))
return(NULL)
})
}
# Test function
test_matlab_equality <- function(r_result, matlab_data, tolerance = 1e-2) {
tryCatch({
common_vars <- intersect(names(r_result), names(matlab_data))
message(paste("Testing", length(common_vars), "common variables"))
for (var in common_vars) {
message(paste("Testing variable:", var))
r_value <- r_result[[var]]
matlab_value <- matlab_data[[var]]
# Convert to vector if it's a single-column data frame
restructure_variable <- function(var) {
if (is.data.frame(var) && ncol(var) == 1) {
# If the variable is a data frame with 1 column, extract the vector
var <- var[[1]]
}
if (is.matrix(var) && ncol(var) == 1) {
# If the variable is a matrix with 1 column, convert to a vector
var <- as.numeric(var)
}
if (is.array(var) && length(dim(var)) == 2 && dim(var)[2] == 1) {
# If the variable is a 2D array with 1 column, convert to a vector
var <- as.numeric(var)
}
return(var)
}
# Restructure r_value and matlab_value
r_value <- restructure_variable(r_value)
matlab_value <- restructure_variable(matlab_value)
# Check if the lengths are the same
expect_equal(length(r_value), length(matlab_value),
info = paste("Length mismatch for variable:", var))
# Check if the values are approximately equal
expect_equal(r_value, matlab_value, tolerance = tolerance,
info = paste("Value mismatch for variable:", var))
}
message("All variables tested successfully")
}, error = function(e) {
message(paste("Error in test_matlab_equality:", e$message))
})
}
tryCatch({
skip_if_not(dir.exists(test_path("data", "matlab_results")),
"MATLAB data directory not found")
skip_if_not(file.exists(test_path("data", "medicare1.csv")),
"Medicare data file not found")
message("Loading MATLAB CSV files")
matlab_data <- load_csv_files(test_path("data", "matlab_results"))
if (is.null(matlab_data)) {
skip("Failed to load MATLAB data")
}
message("Loading R data")
data <- read.csv(test_path("data", "medicare1.csv"))
message(paste("R data dimensions:", nrow(data), "x", ncol(data)))
message("Running npiv_regression")
r_result <- npiv_regression(data, "medicare_share_1983", "d_capital_labor_ratio")
message("Comparing results")
test_matlab_equality(r_result, matlab_data)
message("Test completed successfully")
}, error = function(e) {
message(paste("Error in main test:", e$message))
stop(e)
})
skip_if_not(dir.exists(test_path("data", "matlab_results")),
"MATLAB data directory not found")
skip_if_not(file.exists(test_path("data", "medicare1.csv")),
"Medicare data file not found")
message("Loading MATLAB CSV files")
matlab_data <- load_csv_files(test_path("data", "matlab_results"))
if (is.null(matlab_data)) {
skip("Failed to load MATLAB data")
}
message("Loading R data")
data <- read.csv(test_path("data", "medicare1.csv"))
message(paste("R data dimensions:", nrow(data), "x", ncol(data)))
message("Running npiv_regression")
r_result <- npiv_regression(data, "medicare_share_1983", "d_capital_labor_ratio")
debugonce(npiv_regression)
r_result <- npiv_regression(data, "medicare_share_1983", "d_capital_labor_ratio")
devtools::load_all()
devtools::test()
results_list <- readRDS("~/Documents/uni/master-dissertation/contdid/simulation/results_list.rds")
# saveRDS(results_list, file = "results_list.rds")
# Combine all results into a single data frame
all_results <- do.call(rbind, results_list)
# Calculate mean results
mean_results <- all_results %>%
group_by(n, dgp) %>%
summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)), .groups = "drop")
library(tictoc)
library(parallel)
library(doParallel)
library(foreach)
library(doRNG)
library(tidyverse)
library(fixest)
library(splines2)
library(triangle)
# saveRDS(results_list, file = "results_list.rds")
# Combine all results into a single data frame
all_results <- do.call(rbind, results_list)
# Calculate mean results
mean_results <- all_results %>%
group_by(n, dgp) %>%
summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)), .groups = "drop")
View(mean_results)
library(truncnorm)
devtools::load_all("~/Documents/uni/master-dissertation/contdid")
gdata <- function(n, prop_treated = 0.8) {
# Generate treatment assignment
treatment <- rbinom(n, 1, prop_treated)
# Generate dose for treated units
dose <- rep(0, n)
dose[treatment == 1] <- rtruncnorm(sum(treatment == 1), a = 0.011, b = 0.99, 0.5, 0.16)
dy <- rep(0, n)
dy[treatment == 1] <- -4*(dose[treatment == 1] - 0.5)^2 + 1
# Create dataframe
df <- data.frame(
dy = dy,
treatment = treatment,
dose = dose
)
return(df)
}
data <- gdata(1000)
mean(data$dy[data$treatment == 1]) - mean(data$dy[data$treatment == 0])
result <- npiv_regression(
data = data,
treatment_col = "dose",
outcome_col = "dy",
)
Q
result <- npiv_regression(
data = data,
treatment_col = "dose",
outcome_col = "dy",
)
rm(list=ls())
library(tictoc)
library(parallel)
library(doParallel)
library(foreach)
library(doRNG)
library(tidyverse)
library(fixest)
library(splines2)
library(triangle)
# remove.packages("contdid")
# devtools::build()
# devtools::install()
# devtools::load_all("~/Documents/uni/master-dissertation/contdid")
library(contdid)
# Source necessary functions
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
source("~/Documents/uni/master-dissertation/contdid/simulation/run_simulation.R")
# Set seed
seed1 <- 1234
set.seed(seed1)
n <- c(100, 500, 1000)
nrep <- 1
# Create cluster
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
# Export necessary functions to the cluster
clusterExport(cl, c("dgp_function", "gdata", "run_twfe", "run_feols_bspline", "calculate_point_metrics", "ucb_cvge",
"write_debug_info", "log_dimensions"))
# Run simulations for all DGPs
results_list <- list()
tic()
for (dgp in 2:2) {
# cat("Processing DGP:", dgp, "\n")
dgp_results <- list()
for (sample_size in n) {
# cat("  Sample size:", sample_size, "\n")
tryCatch({
dgp_results[[as.character(sample_size)]] <- run_simulation(n = sample_size, dgp = dgp, nrep = nrep)
# cat("    Completed successfully\n")
}, error = function(e) {
cat("    Error occurred:", conditionMessage(e), "\n")
})
}
results_list[[dgp]] <- do.call(rbind, dgp_results)
# cat("DGP", dgp, "completed\n\n")
}
# Stop cluster
stopCluster(cl)
toc()
View(results_list)
rm(list=ls())
library(tictoc)
library(parallel)
library(doParallel)
library(foreach)
library(doRNG)
library(tidyverse)
library(fixest)
library(splines2)
library(triangle)
# remove.packages("contdid")
# devtools::build()
# devtools::install()
# devtools::load_all("~/Documents/uni/master-dissertation/contdid")
library(contdid)
# Source necessary functions
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
source("~/Documents/uni/master-dissertation/contdid/simulation/run_simulation.R")
# Set seed
seed1 <- 1234
set.seed(seed1)
n <- c(100, 500, 1000)
nrep <- 1
# Create cluster
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
# Export necessary functions to the cluster
clusterExport(cl, c("dgp_function", "gdata", "run_twfe", "run_feols_bspline", "calculate_point_metrics", "ucb_cvge",
"write_debug_info", "log_dimensions"))
# Run simulations for all DGPs
results_list <- list()
tic()
for (dgp in 1:4) {
# cat("Processing DGP:", dgp, "\n")
dgp_results <- list()
for (sample_size in n) {
# cat("  Sample size:", sample_size, "\n")
tryCatch({
dgp_results[[as.character(sample_size)]] <- run_simulation(n = sample_size, dgp = dgp, nrep = nrep)
# cat("    Completed successfully\n")
}, error = function(e) {
cat("    Error occurred:", conditionMessage(e), "\n")
})
}
results_list[[dgp]] <- do.call(rbind, dgp_results)
# cat("DGP", dgp, "completed\n\n")
}
# Stop cluster
stopCluster(cl)
toc()
View(results_list)
saveRDS(results_list, file = "simulation/results_list.rds")
rm(list=ls())
library(tictoc)
library(parallel)
library(doParallel)
library(foreach)
library(doRNG)
library(tidyverse)
library(fixest)
library(splines2)
library(triangle)
# remove.packages("contdid")
# devtools::build()
# devtools::install()
# devtools::load_all("~/Documents/uni/master-dissertation/contdid")
library(contdid)
# Source necessary functions
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
source("~/Documents/uni/master-dissertation/contdid/simulation/run_simulation.R")
# Set seed
seed1 <- 1234
set.seed(seed1)
n <- c(100, 500, 1000)
nrep <- 1
# Create cluster
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
# Export necessary functions to the cluster
clusterExport(cl, c("dgp_function", "gdata", "run_twfe", "run_feols_bspline", "calculate_point_metrics", "ucb_cvge",
"write_debug_info", "log_dimensions"))
# Run simulations for all DGPs
results_list <- list()
tic()
for (dgp in 1:4) {
# cat("Processing DGP:", dgp, "\n")
dgp_results <- list()
for (sample_size in n) {
# cat("  Sample size:", sample_size, "\n")
tryCatch({
dgp_results[[as.character(sample_size)]] <- run_simulation(n = sample_size, dgp = dgp, nrep = nrep)
# cat("    Completed successfully\n")
}, error = function(e) {
cat("    Error occurred:", conditionMessage(e), "\n")
})
}
results_list[[dgp]] <- do.call(rbind, dgp_results)
# cat("DGP", dgp, "completed\n\n")
}
# Stop cluster
stopCluster(cl)
toc()
saveRDS(results_list, file = "simulation/results_list.rds")
rm(list=ls())
library(tictoc)
library(parallel)
library(doParallel)
library(foreach)
library(doRNG)
library(tidyverse)
library(fixest)
library(splines2)
library(triangle)
# remove.packages("contdid")
# devtools::build()
# devtools::install()
# devtools::load_all("~/Documents/uni/master-dissertation/contdid")
library(contdid)
# Source necessary functions
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
source("~/Documents/uni/master-dissertation/contdid/simulation/run_simulation.R")
# Set seed
seed1 <- 1234
set.seed(seed1)
n <- c(100, 500, 1000,2500)
nrep <- 1000
# Create cluster
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
# Export necessary functions to the cluster
clusterExport(cl, c("dgp_function", "gdata", "run_twfe", "run_feols_bspline", "calculate_point_metrics", "ucb_cvge",
"write_debug_info", "log_dimensions"))
# Run simulations for all DGPs
results_list <- list()
tic()
for (dgp in 1:4) {
# cat("Processing DGP:", dgp, "\n")
dgp_results <- list()
for (sample_size in n) {
# cat("  Sample size:", sample_size, "\n")
tryCatch({
dgp_results[[as.character(sample_size)]] <- run_simulation(n = sample_size, dgp = dgp, nrep = nrep)
# cat("    Completed successfully\n")
}, error = function(e) {
cat("    Error occurred:", conditionMessage(e), "\n")
})
}
results_list[[dgp]] <- do.call(rbind, dgp_results)
# cat("DGP", dgp, "completed\n\n")
}
# Stop cluster
stopCluster(cl)
toc()
saveRDS(results_list, file = "simulation/results_list.rds")
# Combine all results into a single data frame
all_results <- do.call(rbind, results_list)
# Calculate mean results
mean_results <- all_results %>%
group_by(n, dgp) %>%
summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)), .groups = "drop")
View(mean_results)
View(results_list)
rm(list=ls())
library(tictoc)
library(parallel)
library(doParallel)
library(foreach)
library(doRNG)
library(tidyverse)
library(fixest)
library(splines2)
library(triangle)
# remove.packages("contdid")
# devtools::build()
# devtools::install()
# devtools::load_all("~/Documents/uni/master-dissertation/contdid")
library(contdid)
# Source necessary functions
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
source("~/Documents/uni/master-dissertation/contdid/simulation/run_simulation.R")
# Set seed
seed1 <- 1234
set.seed(seed1)
n <- c(100, 500, 1000,2500)
nrep <- 1
# Create cluster
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
# Export necessary functions to the cluster
clusterExport(cl, c("dgp_function", "gdata", "run_twfe", "run_feols_bspline", "calculate_point_metrics", "ucb_cvge",
"write_debug_info", "log_dimensions"))
# Run simulations for all DGPs
results_list <- list()
tic()
for (dgp in 1:4) {
# cat("Processing DGP:", dgp, "\n")
dgp_results <- list()
for (sample_size in n) {
# cat("  Sample size:", sample_size, "\n")
tryCatch({
dgp_results[[as.character(sample_size)]] <- run_simulation(n = sample_size, dgp = dgp, nrep = nrep)
# cat("    Completed successfully\n")
}, error = function(e) {
cat("    Error occurred:", conditionMessage(e), "\n")
})
}
results_list[[dgp]] <- do.call(rbind, dgp_results)
# cat("DGP", dgp, "completed\n\n")
}
# Stop cluster
stopCluster(cl)
toc()
View(results_list)
# saveRDS(results_list, file = "simulation/results_list.rds")
# Combine all results into a single data frame
all_results <- do.call(rbind, results_list)
# Calculate mean results
mean_results <- all_results %>%
group_by(n, dgp) %>%
summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)), .groups = "drop")
View(mean_results)
