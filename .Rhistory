if (sum(treatment) > 0) {
smooth_effect <- loess(treatment_effect[treatment == 1] ~ dose[treatment == 1], span = 0.75)
treatment_effect[treatment == 1] <- predict(smooth_effect)
}
# Generate outcomes at time 2 (post-treatment)
y2 <- y1 + treatment_effect + rnorm(n, mean = 0, sd = noise_sd)
# Calculate change in outcomes
dy <- y2 - y1
# Calculate true ATT
att <- mean(treatment_effect[treatment == 1])
# Calculate observed ATE (difference-in-differences)
diff_treated <- mean(dy[treatment == 1])
diff_control <- mean(dy[treatment == 0])
observed_ate <- diff_treated - diff_control
# Calculate true ACR
true_acr <- mean(dgp_params$func_deriv(dose[dose > 0]))
x_grid <- seq(0, 1, length.out = 1000)
func_values <- dgp_params$func(x_grid)
func_deriv_values <- dgp_params$func_deriv(x_grid)
df <- data.frame(
y1 = y1,
y2 = y2,
dy = dy,
treatment = treatment,
dose = dose
)
return(list(
data = df,
info = list(
pop_att = att,
obs_ate = observed_ate,
true_acr = true_acr,
func_values = func_values,
func_deriv_values = func_deriv_values
)
))
}
dat <- gdata(n = n, dgp = dgp)
n
n = 100
dat <- gdata(n = n, dgp = dgp)
data <- dat
View(data)
data <- data[["data"]]
# Set parameters
alpha <- c(0.05)
nx <- 1000
nL <- 8
r <- 4
M <- 5
# Set random seed for reproducibility
set.seed(7654321)
# Run NPIV regression
# debugonce(npiv_regression)
result <- npiv_regression(
data = data,
treatment_col = "dose",
outcome_col = "dy",
alpha = alpha,
nx = nx,
nL = nL,
r = r,
M = M
)
# Extract non-zero treatment and outcome
x <- result$x
y <- result$y
# Create data frames for plotting
df_scatter <- data.frame(x = x, y = y)
df_lines <- data.frame(
x = result$Xx,
hhat = result$hhat,
hhat_upper = result$ATT_upper_UCB,
hhat_lower = result$ATT_lower_UCB,
dhat = result$dhat,
dhat_upper = result$ACR_upper_UCB,
dhat_lower = result$ACR_lower_UCB
)
# Figure 1: Regression Function
p1 <- ggplot() +
geom_point(data = df_scatter, aes(x = x, y = y), color = "gray75", alpha = 0.5) +
geom_line(data = df_lines, aes(x = x, y = hhat), color = "black", size = 1) +
geom_line(data = df_lines, aes(x = x, y = hhat_upper), linetype = "dashed", color = "black", size = 1) +
geom_line(data = df_lines, aes(x = x, y = hhat_lower), linetype = "dashed", color = "black", size = 1) +
labs(x = "Dose", y = "Outcome", title = "NPIV Regression Function") +
theme_minimal() +
theme(text = element_text(size = 14))
print(p1)
# Figure 2: Derivative
p2 <- ggplot(df_lines) +
geom_line(aes(x = x, y = dhat), color = "black", size = 1) +
geom_line(aes(x = x, y = dhat_upper), linetype = "dashed", color = "black", size = 1) +
geom_line(aes(x = x, y = dhat_lower), linetype = "dashed", color = "black", size = 1) +
labs(x = "Dose", y = "Derivative", title = "NPIV Regression Derivative") +
theme_minimal() +
theme(text = element_text(size = 14))
print(p2)
devtools::load_all()
npiv_result <- npiv_regression(
data = data,
treatment_col = "dose",
outcome_col = "dy",
)
devtools::load_all()
npiv_result <- npiv_regression(
data = data,
treatment_col = "dose",
outcome_col = "dy",
)
D <- data[[treatment_col]]
Y <- data[[outcome_col]]
ACR_D <- dhat[findInterval(D, Xx)]
E_ACR <- mean(ACR_D)
psi_D_derivative <- spline_dosage_SR1[findInterval(D, Xx), ]
E_dpsi <- colMeans(psi_D_derivative)
spline_dosage_SR1[findInterval(D, Xx), ]
spline_dosage_SR
npiv_result <- npiv_regression(
data = data,
treatment_col = "dose",
outcome_col = "dy",
)
devtools::load_all()
npiv_result <- npiv_regression(
data = data,
treatment_col = "dose",
outcome_col = "dy",
)
devtools::load_all()
devtools::load_all()
npiv_result <- npiv_regression(
data = data,
treatment_col = "dose",
outcome_col = "dy",
)
n
npiv_result <- npiv_regression(
data = data,
treatment_col = "dose",
outcome_col = "dy",
)
devtools::load_all()
npiv_result <- npiv_regression(
data = data,
treatment_col = "dose",
outcome_col = "dy",
)
true_att <- info[["pop_att"]]
npiv_att_estimate <- npiv_result[["binarised"]][["estimate"]][["binary"]]
npiv_att_se <- npiv_result[["binarised"]][["std_error"]][["binary"]]
npiv_att_l <- npiv_result[["binarised"]][["lower_ci"]]
npiv_att_h <- npiv_result[["binarised"]][["upper_ci"]]
npiv_metrics <- calculate_point_metrics(npiv_att_estimate, true_att, npiv_att_se, npiv_att_l, npiv_att_h)
# Compute UCB coverage
h0 <- info[["func_values"]][order(npiv_result[["Xx"]])]
ucb_result <- compute_ucb_coverage(
h0 = h0,
lower_ucb = npiv_result[["ATT_lower_UCB"]],
upper_ucb = npiv_result[["ATT_upper_UCB"]]
)
ucb_diff <- mean(npiv_result[["ATT_upper_UCB"]] - npiv_result[["ATT_lower_UCB"]])
h0_in_ucb <- mean(h0 >= npiv_result[["ATT_lower_UCB"]] & h0 <= npiv_result[["ATT_upper_UCB"]])
#NPIV ACR
true_acr <- info[["true_acr"]]
npiv_acr_estimate <- npiv_result[["ACR_estimate"]]
npiv_acr_se <- npiv_result[["se_ACR"]]
npiv_acr_l <- npiv_result[["ci_lower_ACR"]]
npiv_acr_h <- npiv_result[["ci_upper_ACR"]]
npiv_metrics_acr <- calculate_point_metrics(npiv_acr_estimate, true_acr, npiv_acr_se, npiv_acr_l, npiv_acr_h)
d0 <- info[["func_deriv_values"]][order(npiv_result[["Xx"]])]
# TWFE
twfe_result <- run_twfe(data)
View(ucb_result)
devtools::load_all()
rm(list=ls())
library(parallel)
library(doParallel)
library(foreach)
library(contdid)
library(doRNG)
library(tidyverse)
library(fixest)
library(splines2)
# Source necessary functions
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
source("~/Documents/uni/master-dissertation/contdid/simulation/run_simulation.R")
# Create cluster
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
# Set seed
seed1 <- 1234
set.seed(seed1)
# Export necessary functions to the cluster
clusterExport(cl, c("dgp_function", "gdata", "run_twfe", "run_feols_bspline", "calculate_point_metrics", "ucb_cvge",
"compute_ucb_coverage"))
# Run simulations for all DGPs
n <- c(100, 500) #, 500, 1000)
nrep <- 2  # or 1 for a single iteration
results_list <- list()
for (dgp in 1:4) {
cat("Processing DGP:", dgp, "\n")
dgp_results <- list()
for (sample_size in n) {
cat("  Sample size:", sample_size, "\n")
tryCatch({
dgp_results[[as.character(sample_size)]] <- run_simulation(n = sample_size, dgp = dgp, nrep = nrep)
cat("    Completed successfully\n")
}, error = function(e) {
cat("    Error occurred:", conditionMessage(e), "\n")
})
}
results_list[[dgp]] <- do.call(rbind, dgp_results)
cat("DGP", dgp, "completed\n\n")
}
# Generate data
# set.seed(1234567)
dat <- gdata(n = 100, dgp = 1)
data <- dat[["data"]]
info <- dat[["info"]]
# # Run estimators and calculate metrics
# NPIV
# debugonce(npiv_regression)
npiv_result <- npiv_regression(
data = data,
treatment_col = "dose",
outcome_col = "dy",
)
true_att <- info[["pop_att"]]
npiv_att_estimate <- npiv_result[["binarised"]][["estimate"]][["binary"]]
npiv_att_se <- npiv_result[["binarised"]][["std_error"]][["binary"]]
npiv_att_l <- npiv_result[["binarised"]][["lower_ci"]]
npiv_att_h <- npiv_result[["binarised"]][["upper_ci"]]
npiv_metrics <- calculate_point_metrics(npiv_att_estimate, true_att, npiv_att_se, npiv_att_l, npiv_att_h)
# Compute UCB coverage
h0 <- info[["func_values"]][order(npiv_result[["Xx"]])]
ucb_result <- compute_ucb_coverage(
h0 = h0,
lower_ucb = npiv_result[["ATT_lower_UCB"]],
upper_ucb = npiv_result[["ATT_upper_UCB"]]
)
ucb_diff <- mean(npiv_result[["ATT_upper_UCB"]] - npiv_result[["ATT_lower_UCB"]])
h0_in_ucb <- mean(h0 >= npiv_result[["ATT_lower_UCB"]] & h0 <= npiv_result[["ATT_upper_UCB"]])
#NPIV ACR
true_acr <- info[["true_acr"]]
npiv_acr_estimate <- npiv_result[["ACR_estimate"]]
npiv_acr_se <- npiv_result[["se_ACR"]]
npiv_acr_l <- npiv_result[["ci_lower_ACR"]]
npiv_acr_h <- npiv_result[["ci_upper_ACR"]]
npiv_metrics_acr <- calculate_point_metrics(npiv_acr_estimate, true_acr, npiv_acr_se, npiv_acr_l, npiv_acr_h)
d0 <- info[["func_deriv_values"]][order(npiv_result[["Xx"]])]
d_ucb_result <- compute_ucb_coverage(
h0 = h0,
lower_ucb = npiv_result[["ACR_upper_UCB"]],
upper_ucb = npiv_result[["ACR_lower_UCB"]]
)
d_ucb_diff <- mean(npiv_result[["ACR_upper_UCB"]]-  npiv_result[["ACR_lower_UCB"]])
d0_in_ucb <- mean(h0 >= npiv_result[["ACR_upper_UCB"]] & h0 <= npiv_result[["ACR_lower_UCB"]])
# TWFE
twfe_result <- run_twfe(data)
twfe_att_estimate <- twfe_result[["acr_estimate"]]
twfe_att_se <- twfe_result[["acr_se"]]
twfe_metrics <- calculate_point_metrics(twfe_att_estimate, true_att, twfe_att_se)
# B-spline
bspline_result <- run_feols_bspline(data)
bspline_att_estimate <- bspline_result[["acr_estimate"]]
bspline_att_se <- bspline_result[["att_se"]]
bspline_metrics <- calculate_point_metrics(bspline_att_estimate, true_att, bspline_att_se)
# Collate all metrics into a single data frame
data.frame(
rep = rep,
n = n,
dgp = dgp,
true_att = true_att,
npiv_att_estimate = npiv_att_estimate,
npiv_att_se = npiv_att_se,
npiv_att_bias = npiv_metrics[["bias"]],
npiv_att_mse = npiv_metrics[["rmse"]],
npiv_att_coverage = as.numeric(npiv_metrics[["coverage"]]),
att_ucb_coverage = ucb_result$coverage,
att_ucb_max_deviation = ucb_result$max_deviation,
att_ucb_diff = ucb_diff,
att_h0_in_ucb = h0_in_ucb,
true_acr = true_acr,
npiv_acr_estimate = npiv_acr_estimate,
npiv_acr_se = npiv_acr_se,
npiv_acr_bias = npiv_metrics_acr[["bias"]],
npiv_acr_mse = npiv_metrics_acr[["rmse"]],
npiv_acr_coverage = as.numeric(npiv_metrics_acr[["coverage"]]),
acr_ucb_coverage = d_ucb_result$coverage,
acr_ucb_max_deviation = d_ucb_result$max_deviation,
acr_ucb_diff = d_ucb_diff,
acr_d0_in_ucb = d0_in_ucb,
twfe_estimate = twfe_att_estimate,
twfe_se = twfe_att_se,
twfe_bias = twfe_metrics[["bias"]],
twfe_mse = twfe_metrics[["rmse"]],
twfe_coverage = as.numeric(twfe_metrics[["coverage"]]),
bspline_estimate = bspline_att_estimate,
bspline_se = bspline_att_se,
bspline_bias = bspline_metrics[["bias"]],
bspline_mse = bspline_metrics[["rmse"]],
bspline_coverage = as.numeric(bspline_metrics[["coverage"]])
)
rep
n
dgp
true_att
npiv_att_estimate
npiv_att_se
npiv_metrics[["bias"]]
npiv_metrics[["rmse"]]
as.numeric(npiv_metrics[["coverage"]])
ucb_result$coverage
ucb_result$max_deviation
ucb_diff
h0_in_ucb
true_acr
npiv_acr_estimate
npiv_acr_se
npiv_metrics_acr[["bias"]]
npiv_metrics_acr[["rmse"]]
as.numeric(npiv_metrics_acr[["coverage"]]),
as.numeric(npiv_metrics_acr[["coverage"]])
d_ucb_result$coverage
d_ucb_result$max_deviation
d_ucb_diff
d0_in_ucb
twfe_att_estimate
twfe_att_se
twfe_metrics[["bias"]]
twfe_metrics[["rmse"]],
twfe_metrics[["rmse"]]
as.numeric(twfe_metrics[["coverage"]])
bspline_att_estimate
bspline_att_se
bspline_metrics[["bias"]]
bspline_metrics[["rmse"]]
as.numeric(bspline_metrics[["coverage"]])
rm(list=ls())
library(parallel)
library(doParallel)
library(foreach)
library(contdid)
library(doRNG)
library(tidyverse)
library(fixest)
library(splines2)
# Source necessary functions
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
source("~/Documents/uni/master-dissertation/contdid/simulation/run_simulation.R")
# Create cluster
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
# Set seed
seed1 <- 1234
set.seed(seed1)
# Export necessary functions to the cluster
clusterExport(cl, c("dgp_function", "gdata", "run_twfe", "run_feols_bspline", "calculate_point_metrics", "ucb_cvge",
"compute_ucb_coverage"))
# Run simulations for all DGPs
n <- c(100, 500) #, 500, 1000)
nrep <- 2  # or 1 for a single iteration
results_list <- list()
for (dgp in 1:4) {
cat("Processing DGP:", dgp, "\n")
dgp_results <- list()
for (sample_size in n) {
cat("  Sample size:", sample_size, "\n")
tryCatch({
dgp_results[[as.character(sample_size)]] <- run_simulation(n = sample_size, dgp = dgp, nrep = nrep)
cat("    Completed successfully\n")
}, error = function(e) {
cat("    Error occurred:", conditionMessage(e), "\n")
})
}
results_list[[dgp]] <- do.call(rbind, dgp_results)
cat("DGP", dgp, "completed\n\n")
}
rm(list=ls())
library(parallel)
library(doParallel)
library(foreach)
library(contdid)
library(doRNG)
library(tidyverse)
library(fixest)
library(splines2)
# Source necessary functions
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
source("~/Documents/uni/master-dissertation/contdid/simulation/run_simulation.R")
# Create cluster
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
# Set seed
seed1 <- 1234
set.seed(seed1)
# Export necessary functions to the cluster
clusterExport(cl, c("dgp_function", "gdata", "run_twfe", "run_feols_bspline", "calculate_point_metrics", "ucb_cvge",
"compute_ucb_coverage"))
# Run simulations for all DGPs
n <- c(100)#, 500) #, 500, 1000)
nrep <- 2  # or 1 for a single iteration
results_list <- list()
for (dgp in 1:4) {
cat("Processing DGP:", dgp, "\n")
dgp_results <- list()
for (sample_size in n) {
cat("  Sample size:", sample_size, "\n")
tryCatch({
dgp_results[[as.character(sample_size)]] <- run_simulation(n = sample_size, dgp = dgp, nrep = nrep)
cat("    Completed successfully\n")
}, error = function(e) {
cat("    Error occurred:", conditionMessage(e), "\n")
})
}
results_list[[dgp]] <- do.call(rbind, dgp_results)
cat("DGP", dgp, "completed\n\n")
}
rm(list=ls())
library(parallel)
library(doParallel)
library(foreach)
library(contdid)
library(doRNG)
library(tidyverse)
library(fixest)
library(splines2)
# Source necessary functions
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
source("~/Documents/uni/master-dissertation/contdid/simulation/run_simulation.R")
# Create cluster
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
# Set seed
seed1 <- 1234
set.seed(seed1)
# Export necessary functions to the cluster
clusterExport(cl, c("dgp_function", "gdata", "run_twfe", "run_feols_bspline", "calculate_point_metrics", "ucb_cvge",
"compute_ucb_coverage"))
# Run simulations for all DGPs
n <- c(100)#, 500) #, 500, 1000)
nrep <- 2  # or 1 for a single iteration
results_list <- list()
for (dgp in 1:4) {
cat("Processing DGP:", dgp, "\n")
dgp_results <- list()
for (sample_size in n) {
cat("  Sample size:", sample_size, "\n")
tryCatch({
dgp_results[[as.character(sample_size)]] <- run_simulation(n = sample_size, dgp = dgp, nrep = nrep)
cat("    Completed successfully\n")
}, error = function(e) {
cat("    Error occurred:", conditionMessage(e), "\n")
})
}
results_list[[dgp]] <- do.call(rbind, dgp_results)
cat("DGP", dgp, "completed\n\n")
}
# Combine all results into a single data frame
all_results <- do.call(rbind, results_list)
# Calculate mean results
mean_results <- all_results %>%
group_by(n, dgp) %>%
summarise(across(where(is.numeric), mean, na.rm = TRUE))
rm(list=ls())
library(parallel)
library(doParallel)
library(foreach)
library(contdid)
library(doRNG)
library(tidyverse)
library(fixest)
library(splines2)
# Source necessary functions
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
source("~/Documents/uni/master-dissertation/contdid/simulation/run_simulation.R")
n <- c(100)#, 500) #, 500, 1000)
nrep <- 2
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = dgp)
dgp = 1
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = dgp)
data <- dat[["data"]]
info <- dat[["info"]]
# # Run estimators and calculate metrics
# NPIV
# debugonce(npiv_regression)
npiv_result <- npiv_regression(
data = data,
treatment_col = "dose",
outcome_col = "dy",
)
remove.packages("contdid")
devtools::install()
rm(list=ls())
library(parallel)
library(doParallel)
library(foreach)
library(contdid)
library(doRNG)
library(tidyverse)
library(fixest)
library(splines2)
# Source necessary functions
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
source("~/Documents/uni/master-dissertation/contdid/simulation/run_simulation.R")
n <- c(100)#, 500) #, 500, 1000)
nrep <- 2
dgp = 1
