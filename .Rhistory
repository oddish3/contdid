y2 <- y1 + treat_noise
# Calculate change in outcomes
dy <- y2 - y1
# Calculate true ATT
pop_att <- dgp_params$E_func
samp_att <- mean(treatment_effect[treatment == 1])
# Calculate observed ATE (difference-in-differences)
diff_treated <- mean(dy[treatment == 1])
diff_control <- mean(dy[treatment == 0])
observed_ate <- diff_treated - diff_control
# Calculate true ACR
samp_acr <- mean(dgp_params$func_deriv(dose[dose > 0]))
pop_acr <- dgp_params$E_deriv
browser()
x_grid <- seq(0, 1, length.out = 1000)
func_values <- dgp_params$func(x_grid)
func_deriv_values <- dgp_params$func_deriv(x_grid)
df <- data.frame(
y1 = y1,
y2 = y2,
dy = dy,
treatment = treatment,
dose = dose
)
return(list(
data = df,
info = list(
pop_att = pop_att,
obs_ate = observed_ate,
pop_acr = pop_acr,
func_values = func_values,
func_deriv_values = func_deriv_values,
noisy_treatment_effect = noisy_treatment_effect
)
))
}
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = dgp)
func_values <- dgp_params$func(x_grid)
func_deriv_values <- dgp_params$func_deriv(x_grid)
<-
x_grid <- if (length(x) == 1) rep(x, 1000) else seq(0, 1, length.out = 1000)
x_grid <- if (length(x) == 1) rep(x, 1000) else seq(0, 1, length.out = 1000)
if (length(x) == 1) rep(x, 1000) else seq(0, 1, length.out = 1000)
func_values <- dgp_params$func(x_grid)
func_deriv_values <- dgp_params$func_deriv(x_grid)
func_values <- dgp_params$func(x_grid)
if (length(x) == 1) {
x_grid <- c(x_grid, rep(x, length(x_grid)))
}
func_deriv_values <- if (is.numeric(dgp_params$func_deriv) && length(dgp_params$func_deriv) == 1) {
rep(dgp_params$func_deriv, length(x_grid))
} else if (is.function(dgp_params$func_deriv)) {
dgp_params$func_deriv(x_grid)
} else {
stop("dgp_params$func_deriv must be either a scalar or a function")
}
is.numeric(dgp_params$func_deriv)
length(dgp_params$func_deriv) == 1
func_deriv_values <- if (length(dgp_params$func_deriv) == 1) {
rep(dgp_params$func_deriv, length(x_grid))
} else if (is.function(dgp_params$func_deriv)) {
dgp_params$func_deriv(x_grid)
} else {
stop("dgp_params$func_deriv must be either a scalar or a function")
}
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = dgp)
# browser()
tryCatch({
if (any(data$dose < 0 | data$dose > 1, na.rm = TRUE)) {
knots <- c(0.4, 0.5, 0.6)
} else {
quantiles <- quantile(data$dose, probs = c(0.25, 0.5, 0.75), na.rm = TRUE)
if (length(unique(quantiles)) == 3) {
margin <- 0.05
knots <- pmax(margin, pmin(1 - margin, quantiles))
} else {
knots <- c(0.4, 0.5, 0.6)
}
}
formula <- bquote(
dy ~ splines2::bSpline(dose, knots = .(knots), degree = 3, intercept = TRUE) - 1
)
model <- suppressWarnings(
fixest::feols(
eval(formula),
data = data,
# cluster = ~ individual
)
)
att_SR <- predict(model)
mean_att_SR <- mean(att_SR)
spline_dosage_SR <- bSpline(data$dose,
knots = knots,
degree = 3,
intercept = TRUE)
n_treated_SR <- sum(data$dose > 0)
infl_reg_SR <- model$residuals * spline_dosage_SR %*%
(MASS::ginv(t(spline_dosage_SR) %*% spline_dosage_SR / n_treated_SR))
infl_att_SR <- infl_reg_SR %*% t(spline_dosage_SR)
se_att_SR <- sqrt(mean(colMeans(infl_att_SR^2)) / n_treated_SR)
derivative_spline_dosage_SR <- dbs(data$dose,
knots = knots,
degree = 3,
intercept = TRUE)
coefficients_SR <- coef(model)
acrt_SR <- as.vector(derivative_spline_dosage_SR %*% coefficients_SR)
acrt_SR_filtered <- acrt_SR[data$dose > 0]
ACR_hat_0 <- mean(acrt_SR_filtered)
list(
att_estimate = mean_att_SR,
att_se = se_att_SR,
acr_estimate = ACR_hat_0
)
}, error = function(e) {
return(list(
att_estimate = NA_real_,
att_se = NA_real_,
acr_estimate = NA_real_,
))
})
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
source("~/Documents/uni/master-dissertation/contdid/R/ucb_cvge.R")
devtools::document()
# # Run estimators and calculate metrics
# NPIV
# debugonce(npiv_regression)
npiv_result <- tryCatch({
result <- npiv_regression(
data = data,
treatment_col = "dose",
outcome_col = "dy",
)
# write_debug_info("npiv_regression completed successfully")
result
}, error = function(e) {
# write_debug_info(paste("Error in npiv_regression:", e$message))
return(NULL)
})
npiv_result <- tryCatch({
result <- npiv_regression(
data = data,
treatment_col = "dose",
outcome_col = "dy",
)
# write_debug_info("npiv_regression completed successfully")
result
}, error = function(e) {
# write_debug_info(paste("Error in npiv_regression:", e$message))
return(NULL)
})
if (is.null(npiv_result)) {
# write_debug_info("Skipping rest of iteration due to npiv_regression failure")
return(NULL)
}
true_att <- info[["pop_att"]]
npiv_att_estimate <- npiv_result[["binarised"]][["estimate"]][["binary"]]
npiv_att_se <- npiv_result[["binarised"]][["std_error"]][["binary"]]
npiv_att_l <- npiv_result[["binarised"]][["lower_ci"]]
npiv_att_h <- npiv_result[["binarised"]][["upper_ci"]]
npiv_metrics <- calculate_point_metrics(npiv_att_estimate, true_att, npiv_att_se, npiv_att_l, npiv_att_h)
# compute true func
x_grid <- seq(0, 1, length.out = length(info$func_values))
closest_indices <- sapply(npiv_result$Xx, function(x) which.min(abs(x_grid - x)))
h0 <- info$func_values[closest_indices]
d0 <- info$func_deriv_values[closest_indices]
info$func_deriv_value
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = dgp)
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = dgp)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = dgp)
x_grid <- seq(0, 1, length.out = 1000)
func_values <- dgp_params$func(x_grid)
func_deriv_values <- if (length(dgp_params$func_deriv) == 1) {
rep(dgp_params$func_deriv, length(x_grid))
} else if (is.function(dgp_params$func_deriv)) {
dgp_params$func_deriv(x_grid)
} else {
stop("dgp_params$func_deriv must be either a scalar or a function")
}
func_deriv_values <- if (length(dgp_params$func_deriv) == 1) {
rep(dgp_params$func_deriv, length(x_grid))
} else if (is.function(dgp_params$func_deriv)) {
dgp_params$func_deriv(x_grid)
} else {
stop("dgp_params$func_deriv must be either a scalar or a function")
}
length(dgp_params$func_deriv) == 1
rep(dgp_params$func_deriv, length(x_grid))
dgp_params$func_deri
dgp_params$func_deriv
length(x_grid)
View(dgp_params)
body(dgp_params[["func_deriv"]])
func_deriv_values <- if (length(dgp_params$func_deriv) == 1) {
rep(body(dgp_params[["func_deriv"]]), length(x_grid))
} else if (is.function(dgp_params$func_deriv)) {
dgp_params$func_deriv(x_grid)
} else {
stop("dgp_params$func_deriv must be either a scalar or a function")
}
func_deriv_values <- if (length(dgp_params$func_deriv) == 1) {
rep(body(dgp_params[["func_deriv"]]), length(x_grid))
} else if (is.function(dgp_params$func_deriv)) {
dgp_params$func_deriv(x_grid)
} else {
stop("dgp_params$func_deriv must be either a scalar or a function")
}
dgp_params$func_deriv) == 1
(length(dgp_params$func_deriv) == 1)
rep(body(dgp_params[["func_deriv"]]), length(x_grid))
is.function(dgp_params$func_deriv)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = dgp)
View(dat)
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 1)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 1)
rep(body(dgp_params[["func_deriv"]]), length(x_grid))
View(dgp_params)
body(dgp_params[["func_deriv"]])
View(dgp_params)
# Define the dgp_function
dgp_function <- function(dgp) {
x_grid <- seq(0, 1, length.out = 1000)
get_values <- function(f) {
if (is.numeric(f) && length(f) == 1) {
rep(f, length(x_grid))
} else if (is.function(f)) {
f(x_grid)
} else {
stop("Input must be either a scalar or a function")
}
}
if (dgp == 1) {
dist <- function(n) runif(n, 0, 1)
func <- function(x) x^2
func_deriv <- function(x) 2*x
E_func <- 1/3
E_deriv <- 1
} else if (dgp == 2) {
dist <- function(n) rtriangle(n, a=0, b=1, c=1)
func <- function(x) 3*x - 1
func_deriv <- 3  # Now a scalar
E_func <- 1/2
E_deriv <- 3
} else if (dgp == 3) {
dist <- function(n) runif(n, 0, 1)
func <- function(x) x^3
func_deriv <- function(x) 3*x^2
E_func <- 1/4
E_deriv <- 1
} else if (dgp == 4) {
dist <- function(n) rbeta(n, 2, 3)
func <- function(x) (x^2 + x) / 2
func_deriv <- function(x) x + 1/2
E_func <- 5/12
E_deriv <- 7/5
} else {
stop("Invalid dgp value")
}
return(list(
dist = dist,
func = get_values(func),
func_deriv = get_values(func_deriv),
E_func = E_func,
E_deriv = E_deriv,
x_grid = x_grid
))
}
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 1)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 1)
# Get the appropriate dist, func, and func_deriv based on the dgp value
dgp_params <- dgp_function(dgp)
# Generate treatment assignment
treatment <- rbinom(n, 1, prop_treated)
# Generate dose for treated units using the dist function
dose <- rep(0, n)
dose[treatment == 1] <- dgp_params$dist(sum(treatment))
# Generate indexes
index_base <- rnorm(n, mean = 100, sd = index_sd)  # Reduced SD for base index
index_unobs_het <- rnorm(n, mean = 0, sd = unobs_het_sd)  # Reduced SD for unobserved heterogeneity
# Generate outcomes at time 1 (pre-treatment)
y1 <- index_base + index_unobs_het + rnorm(n, mean = 0, sd = noise_sd)
# Calculate treatment effect for treated units using the func function
treatment_effect <- ifelse(treatment == 1, dgp_params$func(dose), 0)
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 2)
data <- dat[["data"]]
info <- dat[["info"]]
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 1)
data <- dat[["data"]]
info <- dat[["info"]]
# Define the dgp_function as before
dgp_function <- function(dgp) {
if (dgp == 1) {
dist <- function(n) runif(n, 0, 1)
func <- function(x) x^2
func_deriv <- function(x) 2*x
E_func <- 1/3
E_deriv <- 1
}
if (dgp == 2) {
dist <- function(n) rtriangle(n, a=0, b=1, c=1)
func <- function(x) 3*x - 1
func_deriv <- function(x) rep(3, length(x))
E_func <- 1/2
E_deriv <- 3
}
if (dgp == 3) {
dist <- function(n) runif(n, 0, 1)
func <- function(x) x^3
func_deriv <- function(x) 3*x^2
E_func <- 1/4
E_deriv <- 1
}
if (dgp == 4) {
dist <- function(n) rbeta(n, 2, 3)
func <- function(x) (x^2 + x) / 2
func_deriv <- function(x) x + 1/2
E_func <- 5/12
E_deriv <- 7/5
}
return(list(
dist = dist,
func = func,
func_deriv = func_deriv,
E_func = E_func,
E_deriv = E_deriv
))
}
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 1)
data <- dat[["data"]]
info <- dat[["info"]]
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 2)
data <- dat[["data"]]
info <- dat[["info"]]
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 3)
data <- dat[["data"]]
info <- dat[["info"]]
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 4)
data <- dat[["data"]]
info <- dat[["info"]]
# # Run estimators and calculate metrics
# NPIV
# debugonce(npiv_regression)
npiv_result <- tryCatch({
result <- npiv_regression(
data = data,
treatment_col = "dose",
outcome_col = "dy",
)
# write_debug_info("npiv_regression completed successfully")
result
}, error = function(e) {
# write_debug_info(paste("Error in npiv_regression:", e$message))
return(NULL)
})
# Generate data
# set.seed(1234567)
dat <- gdata(n = n, dgp = 2)
data <- dat[["data"]]
info <- dat[["info"]]
# # Run estimators and calculate metrics
# NPIV
# debugonce(npiv_regression)
npiv_result <- tryCatch({
result <- npiv_regression(
data = data,
treatment_col = "dose",
outcome_col = "dy",
)
# write_debug_info("npiv_regression completed successfully")
result
}, error = function(e) {
# write_debug_info(paste("Error in npiv_regression:", e$message))
return(NULL)
})
if (is.null(npiv_result)) {
# write_debug_info("Skipping rest of iteration due to npiv_regression failure")
return(NULL)
}
true_att <- info[["pop_att"]]
npiv_att_estimate <- npiv_result[["binarised"]][["estimate"]][["binary"]]
npiv_att_se <- npiv_result[["binarised"]][["std_error"]][["binary"]]
npiv_att_l <- npiv_result[["binarised"]][["lower_ci"]]
npiv_att_h <- npiv_result[["binarised"]][["upper_ci"]]
npiv_metrics <- calculate_point_metrics(npiv_att_estimate, true_att, npiv_att_se, npiv_att_l, npiv_att_h)
# compute true func
x_grid <- seq(0, 1, length.out = length(info$func_values))
closest_indices <- sapply(npiv_result$Xx, function(x) which.min(abs(x_grid - x)))
h0 <- info$func_values[closest_indices]
d0 <- info$func_deriv_values[closest_indices]
true_functions <- data.frame(h0 = h0, d0 = d0)
# write.csv(true_functions, "/home/oddish3/Documents/uni/master-dissertation/code-cont/r_true_functions.csv", row.names = FALSE)
# Compute UCB coverage
A <- log(log(npiv_result$TJ[npiv_result$Ltil + 1]))
# Compute coverage for ATT
att_coverage_result <- ucb_cvge(
h0 = h0,
hhat = npiv_result$hhat,
sigh = npiv_result$sigh,
zast = npiv_result$hzast[["95%"]],
theta = npiv_result$thet,
A = A
)
#NPIV ACR
true_acr <- info[["pop_acr"]]
npiv_acr_estimate <- npiv_result[["ACR_estimate"]]
npiv_acr_se <- npiv_result[["se_ACR"]]
npiv_acr_l <- npiv_result[["ci_lower_ACR"]]
npiv_acr_h <- npiv_result[["ci_upper_ACR"]]
npiv_metrics_acr <- calculate_point_metrics(npiv_acr_estimate, true_acr, npiv_acr_se, npiv_acr_l, npiv_acr_h)
# Compute coverage for ACR
acr_coverage_result <- ucb_cvge(
h0 = d0,
hhat = npiv_result$dhat,
sigh = npiv_result$sigd,
zast = npiv_result$dzast[["95%"]],
theta = npiv_result$thet,
A = A
)
npiv_result$dhat
npiv_result$sigd
npiv_result$dzast[["95%"]]
npiv_result$thet
rm(list=ls())
library(tictoc)
library(parallel)
library(doParallel)
library(foreach)
library(doRNG)
library(tidyverse)
library(fixest)
library(splines2)
library(triangle)
# remove.packages("contdid")
# devtools::build()
# devtools::install()
# devtools::load_all("~/Documents/uni/master-dissertation/contdid")
library(contdid)
# Source necessary functions
source("~/Documents/uni/master-dissertation/contdid/simulation/DGP1.R")
source("~/Documents/uni/master-dissertation/contdid/simulation/run_simulation.R")
# Set seed
seed1 <- 1234
set.seed(seed1)
n <- c(100, 500, 1000)
nrep <- 1
# Create cluster
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
# Export necessary functions to the cluster
clusterExport(cl, c("dgp_function", "gdata", "run_twfe", "run_feols_bspline", "calculate_point_metrics", "ucb_cvge",
"write_debug_info", "log_dimensions"))
# Run simulations for all DGPs
results_list <- list()
tic()
for (dgp in 2:2) {
# cat("Processing DGP:", dgp, "\n")
dgp_results <- list()
for (sample_size in n) {
# cat("  Sample size:", sample_size, "\n")
tryCatch({
dgp_results[[as.character(sample_size)]] <- run_simulation(n = sample_size, dgp = dgp, nrep = nrep)
# cat("    Completed successfully\n")
}, error = function(e) {
cat("    Error occurred:", conditionMessage(e), "\n")
})
}
results_list[[dgp]] <- do.call(rbind, dgp_results)
# cat("DGP", dgp, "completed\n\n")
}
# Stop cluster
stopCluster(cl)
toc()
View(results_list)
devtools::test()
