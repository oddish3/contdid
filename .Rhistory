# Initialize dose with zeros for all units
dose <- rep(0, n_total)
# For the treated units, generate dose from a truncated normal distribution
dose[treatment == 1] <- rtruncnorm(sum(treatment), a = 0, b = 1, mean = 0.5, sd = 0.16)
# Calculate the dependent variable dy using the quadratic equation
y <- -4 * (dose - 0.5)^2 + 1
dy[treatment == 0] <- rnorm(sum(treatment == 0), mean = 0.004687925, sd = 0.1013251)
# Create DataFrame
tibble(
id = 1:n_total,
dy = y,
dose = x,
treated = treatment
)
}
# Function to compute true function values
true_function <- function(x) {
4 * (x^2 - 0.5^2)
}
# Step 2 and 3: Compute UCBs and check coverage
check_ucb_coverage <- function(data, n_simulations = 1000) {
result <- npiv_regression(
data = data,
treatment_col = "x",
outcome_col = "y"
)
h0 <- true_function(result$Xx)
coverage_results <- replicate(n_simulations, {
# Resample data
resampled_data <- generate_n_shaped_data(nrow(data))
# Compute UCBs
resampled_result <- npiv_regression(
data = resampled_data,
treatment_col = "x",
outcome_col = "y"
)
ucb_result <- ucb_cvge(
h0 = h0,
hhat = resampled_result$hhat,
sigh = resampled_result$sigh,
zast = resampled_result$hzast,
theta = resampled_result$thet
)
# Check coverage
ucb_result$check
})
# Calculate coverage probability
coverage_prob <- mean(coverage_results)
list(coverage_prob = coverage_prob, result = result)
}
# Generate data
set.seed(123)
sim_data <- generate_dataset(n_total = 1000, prop_treated = 0.5)
rm(list=ls())
library(tidyverse)
library(contdid)
library(truncnorm)
# Step 1: Generate simulated data with n-shaped parabola
generate_dataset <- function(n_total, prop_treated) {
# Generate a binary treatment indicator
treatment <- rbinom(n_total, 1, prop_treated)
# Initialize dose with zeros for all units
dose <- rep(0, n_total)
# For the treated units, generate dose from a truncated normal distribution
dose[treatment == 1] <- rtruncnorm(sum(treatment), a = 0, b = 1, mean = 0.5, sd = 0.16)
# Calculate the dependent variable dy using the quadratic equation
y <- -4 * (dose - 0.5)^2 + 1
y[treatment == 0] <- rnorm(sum(treatment == 0), mean = 0.004687925, sd = 0.1013251)
# Create DataFrame
tibble(
id = 1:n_total,
dy = y,
dose = x,
treated = treatment
)
}
# Function to compute true function values
true_function <- function(x) {
4 * (x^2 - 0.5^2)
}
# Step 2 and 3: Compute UCBs and check coverage
check_ucb_coverage <- function(data, n_simulations = 1000) {
result <- npiv_regression(
data = data,
treatment_col = "x",
outcome_col = "y"
)
h0 <- true_function(result$Xx)
coverage_results <- replicate(n_simulations, {
# Resample data
resampled_data <- generate_n_shaped_data(nrow(data))
# Compute UCBs
resampled_result <- npiv_regression(
data = resampled_data,
treatment_col = "x",
outcome_col = "y"
)
ucb_result <- ucb_cvge(
h0 = h0,
hhat = resampled_result$hhat,
sigh = resampled_result$sigh,
zast = resampled_result$hzast,
theta = resampled_result$thet
)
# Check coverage
ucb_result$check
})
# Calculate coverage probability
coverage_prob <- mean(coverage_results)
list(coverage_prob = coverage_prob, result = result)
}
# Generate data
set.seed(123)
sim_data <- generate_dataset(n_total = 1000, prop_treated = 0.5)
rm(list=ls())
library(tidyverse)
library(contdid)
library(truncnorm)
# Step 1: Generate simulated data with n-shaped parabola
generate_dataset <- function(n_total, prop_treated) {
# Generate a binary treatment indicator
treatment <- rbinom(n_total, 1, prop_treated)
# Initialize dose with zeros for all units
x <- rep(0, n_total)
# For the treated units, generate dose from a truncated normal distribution
x[treatment == 1] <- rtruncnorm(sum(treatment), a = 0, b = 1, mean = 0.5, sd = 0.16)
# Calculate the dependent variable dy using the quadratic equation
y <- -4 * (dose - 0.5)^2 + 1
y[treatment == 0] <- rnorm(sum(treatment == 0), mean = 0.004687925, sd = 0.1013251)
# Create DataFrame
tibble(
id = 1:n_total,
y = y,
x = x,
treated = treatment
)
}
# Function to compute true function values
true_function <- function(x) {
4 * (x^2 - 0.5^2)
}
# Step 2 and 3: Compute UCBs and check coverage
check_ucb_coverage <- function(data, n_simulations = 1000) {
result <- npiv_regression(
data = data,
treatment_col = "x",
outcome_col = "y"
)
h0 <- true_function(result$Xx)
coverage_results <- replicate(n_simulations, {
# Resample data
resampled_data <- generate_n_shaped_data(nrow(data))
# Compute UCBs
resampled_result <- npiv_regression(
data = resampled_data,
treatment_col = "x",
outcome_col = "y"
)
ucb_result <- ucb_cvge(
h0 = h0,
hhat = resampled_result$hhat,
sigh = resampled_result$sigh,
zast = resampled_result$hzast,
theta = resampled_result$thet
)
# Check coverage
ucb_result$check
})
# Calculate coverage probability
coverage_prob <- mean(coverage_results)
list(coverage_prob = coverage_prob, result = result)
}
# Generate data
set.seed(123)
sim_data <- generate_dataset(n_total = 1000, prop_treated = 0.5)
rm(list=ls())
library(tidyverse)
library(contdid)
library(truncnorm)
# Step 1: Generate simulated data with n-shaped parabola
generate_dataset <- function(n_total, prop_treated) {
# Generate a binary treatment indicator
treatment <- rbinom(n_total, 1, prop_treated)
# Initialize dose with zeros for all units
x <- rep(0, n_total)
# For the treated units, generate dose from a truncated normal distribution
x[treatment == 1] <- rtruncnorm(sum(treatment), a = 0, b = 1, mean = 0.5, sd = 0.16)
# Calculate the dependent variable dy using the quadratic equation
y <- -4 * (x - 0.5)^2 + 1
y[treatment == 0] <- rnorm(sum(treatment == 0), mean = 0.004687925, sd = 0.1013251)
# Create DataFrame
tibble(
id = 1:n_total,
y = y,
x = x,
treated = treatment
)
}
sim_data <- generate_dataset(n_total = 1000, prop_treated = 0.5)
# Function to compute true function values
true_function <- function(x) {
4 * (x^2 - 0.5^2)
}
# Step 2 and 3: Compute UCBs and check coverage
check_ucb_coverage <- function(data, n_simulations = 1000) {
result <- npiv_regression(
data = data,
treatment_col = "x",
outcome_col = "y"
)
h0 <- true_function(result$Xx)
coverage_results <- replicate(n_simulations, {
# Resample data
resampled_data <- generate_n_shaped_data(nrow(data))
# Compute UCBs
resampled_result <- npiv_regression(
data = resampled_data,
treatment_col = "x",
outcome_col = "y"
)
ucb_result <- ucb_cvge(
h0 = h0,
hhat = resampled_result$hhat,
sigh = resampled_result$sigh,
zast = resampled_result$hzast,
theta = resampled_result$thet
)
# Check coverage
ucb_result$check
})
# Calculate coverage probability
coverage_prob <- mean(coverage_results)
list(coverage_prob = coverage_prob, result = result)
}
# Generate data
set.seed(123)
# Check coverage
coverage_results <- check_ucb_coverage(sim_data)
View(sim_data)
result <- npiv_regression(
data = data,
treatment_col = "x",
outcome_col = "y"
)
result <- npiv_regression(
data = sim_data,
treatment_col = "x",
outcome_col = "y"
)
View(sim_data)
devtools::load_all(".")
rm(list=ls())
library(tidyverse)
library(contdid)
# Step 1: Generate simulated data with n-shaped parabola
generate_n_shaped_data <- function(n = 1000, noise_sd = 0.1) {
x <- runif(n, -1, 1)
y <- 4 * (x^2 - 0.5^2) + rnorm(n, 0, noise_sd)
data.frame(x = x, y = y)
}
# Function to compute true function values
true_function <- function(x) {
4 * (x^2 - 0.5^2)
}
# Step 2 and 3: Compute UCBs and check coverage
check_ucb_coverage <- function(data, n_simulations = 1000) {
result <- npiv_regression(
data = data,
treatment_col = "x",
outcome_col = "y"
)
h0 <- true_function(result$Xx)
coverage_results <- replicate(n_simulations, {
# Resample data
resampled_data <- generate_n_shaped_data(nrow(data))
# Compute UCBs
resampled_result <- npiv_regression(
data = resampled_data,
treatment_col = "x",
outcome_col = "y"
)
ucb_result <- ucb_cvge(
h0 = h0,
hhat = resampled_result$hhat,
sigh = resampled_result$sigh,
zast = resampled_result$hzast,
theta = resampled_result$thet
)
# Check coverage
ucb_result$check
})
# Calculate coverage probability
coverage_prob <- mean(coverage_results)
list(coverage_prob = coverage_prob, result = result)
}
# Generate data
set.seed(123)
sim_data <- generate_n_shaped_data()
# Check coverage
coverage_results <- check_ucb_coverage(sim_data)
devtools::load_all(".")
rm(list=ls())
library(tidyverse)
library(contdid)
# Step 1: Generate simulated data with n-shaped parabola
generate_n_shaped_data <- function(n = 1000, noise_sd = 0.1) {
x <- runif(n, -1, 1)
y <- 4 * (x^2 - 0.5^2) + rnorm(n, 0, noise_sd)
data.frame(x = x, y = y)
}
# Function to compute true function values
true_function <- function(x) {
4 * (x^2 - 0.5^2)
}
# Step 2 and 3: Compute UCBs and check coverage
check_ucb_coverage <- function(data, n_simulations = 1000) {
result <- npiv_regression(
data = data,
treatment_col = "x",
outcome_col = "y"
)
h0 <- true_function(result$Xx)
coverage_results <- replicate(n_simulations, {
# Resample data
resampled_data <- generate_n_shaped_data(nrow(data))
# Compute UCBs
resampled_result <- npiv_regression(
data = resampled_data,
treatment_col = "x",
outcome_col = "y"
)
ucb_result <- ucb_cvge(
h0 = h0,
hhat = resampled_result$hhat,
sigh = resampled_result$sigh,
zast = resampled_result$hzast,
theta = resampled_result$thet
)
# Check coverage
ucb_result$check
})
# Calculate coverage probability
coverage_prob <- mean(coverage_results)
list(coverage_prob = coverage_prob, result = result)
}
# Generate data
set.seed(123)
sim_data <- generate_n_shaped_data()
# Check coverage
coverage_results <- check_ucb_coverage(sim_data)
compute_eta_values <- function(data, treatment_col, outcome_col, Xx_sub, dhat, spline_dosage_SR, spline_dosage_SR1, u_hat) {
D <- data[[treatment_col]]
Y <- data[[outcome_col]]
ACR_D <- dhat[findInterval(D, Xx_sub)]
E_ACR <- mean(ACR_D)
psi_D_derivative <- spline_dosage_SR1[findInterval(D, Xx_sub), ]
E_dpsi <- colMeans(psi_D_derivative)
psi_D <- spline_dosage_SR[findInterval(D, Xx_sub), ]
E_psi_psi_inv <- MASS::ginv(t(psi_D) %*% psi_D / nrow(data))
correction_term <- (psi_D %*% E_psi_psi_inv %*% E_dpsi) * u_hat
ACR_D - E_ACR + as.vector(correction_term)
}
eta_values <- compute_eta_values(data, treatment_col, outcome_col, Xx_sub, dhat, spline_dosage_SR, spline_dosage_SR1, u_hat)
devtools::load_all(".")
rm(list=ls())
library(tidyverse)
library(contdid)
# Step 1: Generate simulated data with n-shaped parabola
generate_n_shaped_data <- function(n = 1000, noise_sd = 0.1) {
x <- runif(n, -1, 1)
y <- 4 * (x^2 - 0.5^2) + rnorm(n, 0, noise_sd)
data.frame(x = x, y = y)
}
# Function to compute true function values
true_function <- function(x) {
4 * (x^2 - 0.5^2)
}
# Step 2 and 3: Compute UCBs and check coverage
check_ucb_coverage <- function(data, n_simulations = 1000) {
result <- npiv_regression(
data = data,
treatment_col = "x",
outcome_col = "y"
)
h0 <- true_function(result$Xx)
coverage_results <- replicate(n_simulations, {
# Resample data
resampled_data <- generate_n_shaped_data(nrow(data))
# Compute UCBs
resampled_result <- npiv_regression(
data = resampled_data,
treatment_col = "x",
outcome_col = "y"
)
ucb_result <- ucb_cvge(
h0 = h0,
hhat = resampled_result$hhat,
sigh = resampled_result$sigh,
zast = resampled_result$hzast,
theta = resampled_result$thet
)
# Check coverage
ucb_result$check
})
# Calculate coverage probability
coverage_prob <- mean(coverage_results)
list(coverage_prob = coverage_prob, result = result)
}
# Generate data
set.seed(123)
sim_data <- generate_n_shaped_data()
# Check coverage
coverage_results <- check_ucb_coverage(sim_data)
force(data)
force(dhat)
force(outcome_col)
force(spline_dosage_SR)
force(spline_dosage_SR1)
force(treatment_col)
force(u_hat)
force(Xx_sub)
dim(data)
dim(treatment_col)
rm(list=ls())
load("/home/oddish3/Downloads/medicare1(1).RData")
library(tidyverse)
library(contdid)
result <- npiv_regression(
data = medicare1,
treatment_col = "medicare_share_1983",
outcome_col = "d_capital_labor_ratio"
)
View(medicare1)
plot(result[["x"]], result[["y"]], pch = 20, col = rgb(0.75, 0.75, 0.75, 0.5),
xlab = 'Medicare Share 1983', ylab = 'Capital-Labor Ratio',
main = 'Nonparametric Regression: Capital-Labor Ratio vs Medicare Share')
rm(list=ls())
load("/home/oddish3/Downloads/medicare1(1).RData")
library(tidyverse)
library(contdid)
result <- npiv_regression(
data = medicare1,
treatment_col = "medicare_share_1983",
outcome_col = "d_capital_labor_ratio"
)
# result <- data.frame(result)
plot(result[["x"]], result[["y"]], pch = 20, col = rgb(0.75, 0.75, 0.75, 0.5),
xlab = 'Medicare Share 1983', ylab = 'Capital-Labor Ratio',
main = 'Nonparametric Regression: Capital-Labor Ratio vs Medicare Share')
rm(list=ls())
library(tidyverse)
library(contdid)
# Step 1: Generate simulated data with n-shaped parabola
generate_n_shaped_data <- function(n = 1000, noise_sd = 0.1) {
x <- runif(n, -1, 1)
y <- 4 * (x^2 - 0.5^2) + rnorm(n, 0, noise_sd)
data.frame(x = x, y = y)
}
# Function to compute true function values
true_function <- function(x) {
4 * (x^2 - 0.5^2)
}
# Step 2 and 3: Compute UCBs and check coverage
check_ucb_coverage <- function(data, n_simulations = 1000) {
result <- npiv_regression(
data = data,
treatment_col = "x",
outcome_col = "y"
)
h0 <- true_function(result$Xx)
coverage_results <- replicate(n_simulations, {
# Resample data
resampled_data <- generate_n_shaped_data(nrow(data))
# Compute UCBs
resampled_result <- npiv_regression(
data = resampled_data,
treatment_col = "x",
outcome_col = "y"
)
ucb_result <- ucb_cvge(
h0 = h0,
hhat = resampled_result$hhat,
sigh = resampled_result$sigh,
zast = resampled_result$hzast,
theta = resampled_result$thet
)
# Check coverage
ucb_result$check
})
# Calculate coverage probability
coverage_prob <- mean(coverage_results)
list(coverage_prob = coverage_prob, result = result)
}
# Generate data
set.seed(123)
sim_data <- generate_n_shaped_data()
rm(list=ls())
load("/home/oddish3/Downloads/medicare1(1).RData")
library(tidyverse)
library(contdid)
result <- npiv_regression(
data = medicare1,
treatment_col = "medicare_share_1983",
outcome_col = "d_capital_labor_ratio"
)
rm(list = ls())
getwd()
devtools::document()
devtools::install()
library(contdid)
devtools::clean_dll()
devtools::load_all()
